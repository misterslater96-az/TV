bash << 'EOF'
set -e

mkdir -p "$HOME/.local/bin"

cat > "$HOME/.local/bin/tv" << 'TVEOF'
#!/usr/bin/env bash
# TV 4.1 Runtime
# - TVpass curated list + EPG
# - Clickable everything via fzf (main menu, channels, global)
# - Faux GUI: emojis, blocky menu, breadcrumb nav at top
# - DVR: live toggle + scheduled + series timers
# - HDD/SSD-aware background recording limits
# - mpv call simplified so it actually plays (no over-quiet weirdness)

TV_DIR="$HOME/TV"
PLAYLIST="$TV_DIR/playlist.m3u"
EPG="$TV_DIR/epg.xml"
TVPASS_PLS="https://tvpass.org/playlist/m3u"
TVPASS_EPG="https://tvpass.org/epg.xml"
INPUT_CONF="$TV_DIR/tv-input.conf"
RECDIR="$TV_DIR/recordings"
REC_PIDFILE="$TV_DIR/recording.pid"
GUIDE_CACHE="$TV_DIR/guide-cache.txt"
NOW_CACHE="$TV_DIR/now-cache.txt"
EPG4_CACHE="$TV_DIR/epg-four.txt"
NAME_NOW_CACHE="$TV_DIR/now-by-name.txt"
TIMERS_DB="$TV_DIR/timers.db"

MAIN_PLAYLIST="$TV_DIR/main.m3u"
GLOBAL_INDEX="$TV_DIR/global-index.m3u"
MAIN_URL="https://iptv-org.github.io/iptv/countries/us.m3u"
GLOBAL_INDEX_URL="https://iptv-org.github.io/iptv/index.m3u"

mkdir -p "$TV_DIR" "$RECDIR"

RECORD_CONFIRM=""
STORAGE_TIER="hdd"
MAX_BG_RECORDINGS=3
MAX_LIVE_RECORDINGS=1

#########################################
# STORAGE TIER (HDD vs SSD)
#########################################
detect_storage_tier() {
  local dev base rota
  dev=$(df --output=source "$TV_DIR" 2>/dev/null | tail -n1)
  [ -z "$dev" ] && { STORAGE_TIER="hdd"; MAX_BG_RECORDINGS=3; return; }
  base="${dev%%[0-9p]*}"
  rota=$(lsblk -ndo ROTA "$base" 2>/dev/null | head -n1)
  case "$rota" in
    0) STORAGE_TIER="ssd"; MAX_BG_RECORDINGS=6 ;;
    1) STORAGE_TIER="hdd"; MAX_BG_RECORDINGS=3 ;;
    *) STORAGE_TIER="hdd"; MAX_BG_RECORDINGS=3 ;;
  esac
}

active_bg_recordings() {
  local live
  live=""
  [ -f "$REC_PIDFILE" ] && live=$(cat "$REC_PIDFILE" 2>/dev/null || echo "")
  ps ax -o pid= -o args= 2>/dev/null | awk -v live="$live" -v rec="$RECDIR" '
    index($0,"ffmpeg") && index($0,rec) {
      if ($1 != live) count++
    }
    END{print count+0}'
}

prevent_sleep() {
  if command -v xset >/dev/null 2>&1; then
    xset s off -dpms >/dev/null 2>&1 || true
  fi
}

#########################################
# DEPS: mpv, curl, thunar, fzf
#########################################
ensure_deps() {
  local need_base=0 need_fzf=0
  command -v mpv    >/dev/null 2>&1 || need_base=1
  command -v curl   >/dev/null 2>&1 || need_base=1
  command -v thunar >/dev/null 2>&1 || need_base=1
  command -v fzf    >/dev/null 2>&1 || need_fzf=1

  if [ "$need_base" -eq 1 ] && command -v apt >/dev/null 2>&1; then
    echo ">>> Installing mpv, curl, thunar..."
    sudo apt update
    sudo apt install -y mpv curl thunar
  fi

  if [ "$need_fzf" -eq 1 ] && command -v apt >/dev/null 2>&1; then
    echo ">>> Installing fzf for clickable UI..."
    sudo apt install -y fzf || true
  fi
}

#########################################
# DISCLAIMER
#########################################
show_disclaimer() {
  clear
  cat << 'EOD'
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
â–ˆ ðŸ“º  TV 4.1 â€“ CLICKABLE TIVO-BRAIN TERMINAL  â–ˆ
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

Controls (everywhere fzf is used):
  â€¢ Mouse or â†‘/â†“ â†’ move
  â€¢ Enter        â†’ select
  â€¢ Esc          â†’ cancel/back

While watching:
  â€¢ Ctrl+Up / Ctrl+Down â†’ surf channels
  â€¢ 1 or r              â†’ toggle LIVE recording
  â€¢ q / Esc             â†’ back to menu

DVR:
  â€¢ Live toggle with 1 / r (one live at a time)
  â€¢ Timers via daily guide & "record all Name"
  â€¢ Background recordings limited by disk type:
       HDD â†’ 3 at once
       SSD â†’ 6 at once

EOD
  read -rp "Press ENTER to continue... " _
}

#########################################
# MPV INPUT CONF
#########################################
ensure_input_conf() {
  cat > "$INPUT_CONF" << 'EOT'
ctrl+UP no-osd quit 3
ctrl+DOWN no-osd quit 4
1 no-osd quit 5
r no-osd quit 5
EOT
}

#########################################
# TVPASS FETCH
#########################################
tvpass_ensure_playlist() {
  if [ ! -s "$PLAYLIST" ]; then
    echo ">>> Downloading TVpass playlist..."
    curl -sS -L "$TVPASS_PLS" -o "$PLAYLIST"
  fi
}
tvpass_ensure_guide() {
  if [ ! -s "$EPG" ]; then
    echo ">>> Downloading TVpass EPG..."
    curl -sS -L "$TVPASS_EPG" -o "$EPG"
  fi
}
tvpass_update_all() {
  echo "âŸ³ Updating TVpass playlist + guide..."
  curl -sS -L "$TVPASS_PLS" -o "$PLAYLIST"
  curl -sS -L "$TVPASS_EPG" -o "$EPG"
  echo "âœ” Done."
  exit 0
}

build_table() {
  local TMP
  TMP=$(mktemp)
  awk -v OFS='\t' '
    BEGIN{n=0; name=""}
    /^#EXTINF/{
      sub(/.*,/, "", $0); name=$0; next
    }
    /^http/{
      if (n >= 177) next
      n++; print n, (name==""?"Unknown":name), $0; name=""
    }
  ' "$PLAYLIST" > "$TMP"
  echo "$TMP"
}

#########################################
# GUIDE CACHES (Python)
#########################################
build_guide_cache() {
  local TABLE="$1"
  : > "$GUIDE_CACHE"
  : > "$NOW_CACHE"
  : > "$EPG4_CACHE"
  : > "$NAME_NOW_CACHE"

  python3 - "$EPG" "$TABLE" "$GUIDE_CACHE" "$NOW_CACHE" "$EPG4_CACHE" "$NAME_NOW_CACHE" << 'PY'
import sys, re
from datetime import datetime
import xml.etree.ElementTree as ET

epg_path, table_path, guide_path, now_path, four_path, name_now_path = sys.argv[1:]

tree = ET.parse(epg_path)
root = tree.getroot()

def canon_name(s: str) -> str:
    s = s or ""
    s = re.sub(r"\[[^\]]*\]", " ", s)
    s = re.sub(r"\([^)]*\)", " ", s)
    s = re.sub(r"[-â€“_|]", " ", s)
    for token in ["HD","East","West","US","USA","Feed","TV","Channel","Network","Latino"]:
        s = re.sub(r"\b"+re.escape(token)+r"\b"," ",s,flags=re.I)
    s = re.sub(r"\s+"," ",s).strip().lower()
    return s

channels = []
for ch in root.findall("channel"):
    cid = ch.get("id","")
    names = [dn.text.strip() for dn in ch.findall("display-name") if dn.text]
    channels.append((cid,names))

def find_channel_id(name):
    name = (name or "").strip()
    if not name:
        return None
    for cid,names in channels:
        for dn in names:
            if dn == name:
                return cid
    short = canon_name(name)
    if not short:
        return None
    for cid,names in channels:
        joined = " ".join(n for n in names if n)
        if short and short in canon_name(joined):
            return cid
    return None

progs_by_id = {}
for p in root.findall("programme"):
    cid = p.get("channel")
    if not cid: continue
    progs_by_id.setdefault(cid,[]).append(p)

def parse_dt(s):
    if not s: return None
    for fmt in ("%Y%m%d%H%M%S %z","%Y%m%d%H%M%S%z"):
        try:
            return datetime.strptime(s,fmt).astimezone()
        except Exception:
            continue
    return None

now = datetime.now().astimezone()

def blocks_from_now(cid):
    progs = progs_by_id.get(cid,[])
    out = []
    for p in progs:
        st = parse_dt(p.get("start"))
        en = parse_dt(p.get("stop"))
        if not st or not en: continue
        if en <= now: continue
        t_el = p.find("title")
        title = (t_el.text.strip() if (t_el is not None and t_el.text) else "")
        if title:
            out.append((st,en,title))
        if len(out) >= 4:
            break
    return out

with open(table_path,"r",encoding="utf-8") as tf, \
     open(guide_path,"w",encoding="utf-8") as gf, \
     open(now_path,"w",encoding="utf-8") as nf, \
     open(four_path,"w",encoding="utf-8") as ff, \
     open(name_now_path,"w",encoding="utf-8") as nfname:

    seen = set()
    for line in tf:
        parts = line.rstrip("\n").split("\t")
        if len(parts) < 3: continue
        num,name,url = parts[0],parts[1],parts[2]
        if not num: continue
        cid = find_channel_id(name)
        if not cid: continue
        blocks = blocks_from_now(cid)
        if not blocks: continue

        titles = [b[2] for b in blocks]

        nf.write(f"{num}\t{name}\t{titles[0]}\n")

        key = canon_name(name)
        if key and key not in seen:
            nfname.write(f"{key}\t{titles[0]}\n")
            seen.add(key)

        four_titles = titles + [""]*(4-len(titles))
        ff.write(f"{num}\t" + "\t".join(four_titles[:4]) + "\n")

        for st,en,title in blocks:
            tstr = f"{st.strftime('%-I:%M %p')}-{en.strftime('%-I:%M %p')}"
            gf.write(f"\x1b[96m{num}. {name}\x1b[0m\n")
            gf.write(f"   {tstr}  {title}\n")
        gf.write("\n")
PY
}

now_title_for_num() {
  local num="$1"
  [ -f "$NOW_CACHE" ] || return
  awk -F'\t' -v n="$num" '$1==n{print $3;exit}' "$NOW_CACHE" 2>/dev/null
}

epg_now_next_block() {
  local num="$1"
  [ -f "$EPG4_CACHE" ] || return
  local line
  line=$(awk -F'\t' -v n="$num" '$1==n{print;exit}' "$EPG4_CACHE" 2>/dev/null)
  [ -z "$line" ] && return
  IFS=$'\t' read -r _ NOW NEXT AFTER LATER <<< "$line"
  [ -n "$NOW" ]  && echo -e "   \e[91mNOW:  $NOW\e[0m"
  [ -n "$NEXT" ] && echo    "   NEXT: $NEXT"
  [ -n "$AFTER" ]&& echo    "   AFTER: $AFTER"
  [ -n "$LATER" ]&& echo    "   LATER: $LATER"
}

#########################################
# DVR: LIVE
#########################################
recording_active() {
  [ -f "$REC_PIDFILE" ] || return 1
  local pid
  pid=$(cat "$REC_PIDFILE" 2>/dev/null || echo "")
  [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null
}

start_recording() {
  local url="$1" chan="$2" show="$3"
  local chsafe showsafe day ts dir outfile
  chsafe=$(echo "$chan" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  [ -z "$chsafe" ] && chsafe="Channel"
  [ -n "$show" ] && showsafe=$(echo "$show" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  day=$(date +"%Y-%m-%d")
  ts=$(date +"%Y-%m-%d_%H-%M-%S")
  dir="$RECDIR/$chsafe/$day"
  mkdir -p "$dir"
  if [ -n "$showsafe" ]; then
    outfile="$dir/${chsafe}_${showsafe}_$ts.ts"
  else
    outfile="$dir/${chsafe}_$ts.ts"
  fi
  echo ">>> LIVE recording â†’ $outfile"
  (
    ffmpeg -nostdin -y -i "$url" -c copy "$outfile" >/dev/null 2>&1
    rm -f "$REC_PIDFILE"
  ) &
  echo $! > "$REC_PIDFILE"
}

stop_recording() {
  local pid
  pid=$(cat "$REC_PIDFILE" 2>/dev/null || echo "")
  if [ -n "$pid" ]; then
    kill "$pid" 2>/dev/null || true
    wait "$pid" 2>/dev/null || true
  fi
  rm -f "$REC_PIDFILE"
  echo ">>> LIVE recording stopped."
}

toggle_recording() {
  local url="$1" chan="$2" num="$3"
  if recording_active; then
    if [ "$RECORD_CONFIRM" != "yes" ]; then
      echo ">>> LIVE recording already running."
      echo ">>> Press 1 or r again to STOP it."
      RECORD_CONFIRM="yes"
      return
    fi
    stop_recording
    RECORD_CONFIRM=""
  else
    RECORD_CONFIRM=""
    local show=""
    [ -n "$num" ] && show=$(now_title_for_num "$num")
    start_recording "$url" "$chan" "$show"
  fi
}

#########################################
# SCHEDULED RECORDING (BLOCKS)
#########################################
schedule_record_block() {
  local url="$1" chan="$2" show="$3" start_ts="$4" end_ts="$5" label="$6"
  local now_ts duration delay
  now_ts=$(date +%s)
  duration=$((end_ts - start_ts))
  [ "$duration" -le 0 ] && { echo "Block already done."; return; }
  delay=$((start_ts - now_ts))
  if [ "$delay" -lt 0 ]; then
    delay=0
    duration=$((end_ts - now_ts))
    [ "$duration" -le 0 ] && { echo "Block already finished."; return; }
  fi
  local chsafe showsafe day ts dir outfile
  chsafe=$(echo "$chan" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  [ -z "$chsafe" ] && chsafe="Channel"
  [ -n "$show" ] && showsafe=$(echo "$show" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  day=$(date -d "@$start_ts" +"%Y-%m-%d")
  ts=$(date -d "@$start_ts" +"%Y-%m-%d_%H-%M-%S")
  dir="$RECDIR/$chsafe/$day"
  mkdir -p "$dir"
  if [ -n "$showsafe" ]; then
    outfile="$dir/${chsafe}_${showsafe}_$ts.ts"
  else
    outfile="$dir/${chsafe}_$ts.ts"
  fi

  if [ -f "$outfile" ]; then
    echo ">>> Already have recording for $chan â€“ $show at $label, skipping."
    return
  fi

  local current
  current=$(active_bg_recordings)
  if [ "$current" -ge "$MAX_BG_RECORDINGS" ]; then
    echo ">>> âš  Background cap hit ($current/$MAX_BG_RECORDINGS). Not scheduling:"
    echo "    $chan â€“ $show ($label)"
    return
  fi

  nohup bash -c "
    sleep $delay
    ffmpeg -nostdin -y -i \"$url\" -t $duration -c copy \"$outfile\" >/dev/null 2>&1
  " >/dev/null 2>&1 &

  echo ">>> TIMER scheduled: $chan"
  echo "    Block: $label â€“ $show"
  echo "    File:  $outfile"
}

#########################################
# SERIES TIMERS
#########################################
add_series_timer() {
  local num="$1" title="$2"
  [ -z "$num" ] || [ -z "$title" ] && return
  mkdir -p "$TV_DIR"
  local norm
  norm=$(printf '%s\n' "$title" | sed 's/^ *//;s/ *$//')
  if [ -f "$TIMERS_DB" ] && awk -F'\t' -v n="$num" -v t="$(printf '%s\n' "$norm" | tr 'A-Z' 'a-z')" '
    {
      if (NF>=2 && $1==n && tolower($2)==t) { found=1 }
    }
    END{exit !found}
  ' "$TIMERS_DB"; then
    echo "Series timer already exists: $num â€“ $norm"
    return
  fi
  echo -e "${num}\t${norm}" >> "$TIMERS_DB"
  echo ">>> Added series timer: ch ${num} â€“ ${norm}"
}

timers_list() {
  if [ ! -s "$TIMERS_DB" ]; then
    echo "No series timers."
    return
  fi
  echo "â± Series Timers:"
  echo "-----------------------------"
  nl -ba "$TIMERS_DB" | sed 's/\t/  â†’  /'
}

timers_scan() {
  tvpass_ensure_playlist
  tvpass_ensure_guide
  [ ! -s "$TIMERS_DB" ] && { echo "No timers to scan."; return; }

  local TABLE TMP
  TABLE=$(build_table)
  TMP=$(mktemp)

  python3 - "$EPG" "$TIMERS_DB" "$TABLE" > "$TMP" << 'PY'
import sys, re
from datetime import datetime, timedelta
import xml.etree.ElementTree as ET

epg_path, timers_path, table_path = sys.argv[1:]

tree = ET.parse(epg_path)
root = tree.getroot()

def canon_name(s: str) -> str:
    s = s or ""
    s = re.sub(r"\[[^\]]*\]", " ", s)
    s = re.sub(r"\([^)]*\)", " ", s)
    s = re.sub(r"[-â€“_|]", " ", s)
    for token in ["HD","East","West","US","USA","Feed","TV","Channel","Network","Latino"]:
        s = re.sub(r"\b"+re.escape(token)+r"\b"," ",s,flags=re.I)
    s = re.sub(r"\s+"," ",s).strip().lower()
    return s

channels = []
for ch in root.findall("channel"):
    cid = ch.get("id","")
    names = [dn.text.strip() for dn in ch.findall("display-name") if dn.text]
    channels.append((cid,names))

def find_channel_id(name):
    name = (name or "").strip()
    if not name: return None
    for cid,names in channels:
        for dn in names:
            if dn == name:
                return cid
    short = canon_name(name)
    if not short: return None
    for cid,names in channels:
        joined = " ".join(n for n in names if n)
        if short and short in canon_name(joined):
            return cid
    return None

progs_by_id = {}
for p in root.findall("programme"):
    cid = p.get("channel")
    if not cid: continue
    progs_by_id.setdefault(cid,[]).append(p)

def parse_dt(s):
    if not s: return None
    for fmt in ("%Y%m%d%H%M%S %z","%Y%m%d%H%M%S%z"):
        try:
            return datetime.strptime(s,fmt).astimezone()
        except Exception:
            continue
    return None

num_to_name = {}
with open(table_path,"r",encoding="utf-8") as tf:
    for line in tf:
        parts = line.rstrip("\n").split("\t")
        if len(parts) < 2: continue
        num,name = parts[0],parts[1]
        num_to_name[num] = name

now = datetime.now().astimezone()
horizon = now + timedelta(days=2)

def human_label(st,en):
    return f"{st.strftime('%-I:%M %p')}-{en.strftime('%-I:%M %p')}"

with open(timers_path,"r",encoding="utf-8") as tf:
    for line in tf:
        line=line.strip()
        if not line: continue
        parts=line.split("\t",1)
        if len(parts)<2: continue
        num,title = parts[0],parts[1].strip()
        chan_name = num_to_name.get(num)
        if not chan_name: continue
        cid = find_channel_id(chan_name)
        if not cid: continue
        progs = progs_by_id.get(cid,[])
        wanted = title.lower()
        for p in progs:
            st = parse_dt(p.get("start"))
            en = parse_dt(p.get("stop"))
            if not st or not en: continue
            if en<=now or st>=horizon: continue
            t_el=p.find("title")
            ttxt=(t_el.text.strip() if (t_el is not None and t_el.text) else "")
            if not ttxt: continue
            if ttxt.strip().lower()!=wanted: continue
            label = human_label(st,en)
            print(f"{num}\t{int(st.timestamp())}\t{int(en.timestamp())}\t{ttxt}\t{label}")
PY

  if [ ! -s "$TMP" ]; then
    echo "No upcoming episodes found."
    rm -f "$TMP" "$TABLE"
    return
  fi

  echo ">>> Scheduling episodes..."
  while IFS=$'\t' read -r NUM ST_TS EN_TS TITLE LABEL; do
    [ -z "$NUM" ] && continue
    local NAME URL
    NAME=$(awk -F'\t' -v i="$NUM" '$1==i{print $2}' "$TABLE")
    URL=$(awk -F'\t' -v i="$NUM" '$1==i{print $3}' "$TABLE")
    [ -z "$URL" ] && continue
    schedule_record_block "$URL" "$NAME" "$TITLE" "$ST_TS" "$EN_TS" "$LABEL"
  done < "$TMP"

  rm -f "$TMP" "$TABLE"
}

#########################################
# PLAY CHANNEL (TVPASS)
#########################################
play_channel() {
  local CUR="$1" TABLE="$2"
  local LAST NAME URL
  LAST=$(awk -F'\t' 'END{print $1}' "$TABLE")

  while true; do
    NAME=$(awk -F'\t' -v i="$CUR" '$1==i{print $2}' "$TABLE")
    URL=$(awk -F'\t' -v i="$CUR" '$1==i{print $3}' "$TABLE")

    clear
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘ TV â–¸ TVpass â–¸ Watching                 â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "\e[96mâ–¶ Channel $CUR: $NAME\e[0m"
    echo
    epg_now_next_block "$CUR"
    echo
    recording_active && echo -e "   \e[91mâ— LIVE RECORDING (1/r to stop)\e[0m\n"
    echo "   Ctrl+Up/Down â†’ surf | 1/r â†’ live rec | q/Esc â†’ back"
    echo

    if [ -z "$URL" ]; then
      echo "!!! No URL for channel $CUR"
      read -rp "Press ENTER..." _
      break
    fi

    mpv --fullscreen --input-conf="$INPUT_CONF" "$URL"
    local code=$?
    case "$code" in
      3) CUR=$((CUR+1)); [ "$CUR" -gt "$LAST" ] && CUR=1 ;;
      4) CUR=$((CUR-1)); [ "$CUR" -lt 1 ] && CUR="$LAST" ;;
      5) toggle_recording "$URL" "$NAME" "$CUR" ;;
      *) break ;;
    esac
  done
}

#########################################
# DAILY GUIDE (TVPASS)
#########################################
channel_full_guide() {
  local NUM="$1" TABLE="$2"
  local NAME URL MAP
  NAME=$(awk -F'\t' -v i="$NUM" '$1==i{print $2}' "$TABLE")
  URL=$(awk -F'\t' -v i="$NUM" '$1==i{print $3}' "$TABLE")
  [ -z "$NAME" ] && { echo "No such channel."; read -rp "ENTER..." _; return; }

  MAP=$(mktemp)
  clear
  echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
  echo "â•‘ TV â–¸ TVpass â–¸ Guide â–¸ $NUM             â•‘"
  echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo -e "\e[93mDaily guide for $NUM â€“ $NAME\e[0m"
  echo

  python3 - "$EPG" "$NAME" "$MAP" << 'PY'
import sys, re
from datetime import datetime, timedelta
import xml.etree.ElementTree as ET

epg_path, playlist_name, map_path = sys.argv[1:]

tree = ET.parse(epg_path)
root = tree.getroot()

def canon_name(s: str) -> str:
    s = s or ""
    s = re.sub(r"\[[^\]]*\]", " ", s)
    s = re.sub(r"\([^)]*\)", " ", s)
    s = re.sub(r"[-â€“_|]", " ", s)
    for token in ["HD","East","West","US","USA","Feed","TV","Channel","Network","Latino"]:
        s = re.sub(r"\b"+re.escape(token)+r"\b"," ",s,flags=re.I)
    s = re.sub(r"\s+"," ",s).strip().lower()
    return s

def find_channel_id(name):
    name=(name or "").strip()
    if not name: return None
    chans=[]
    for ch in root.findall("channel"):
        cid=ch.get("id","")
        names=[dn.text.strip() for dn in ch.findall("display-name") if dn.text]
        chans.append((cid,names))
    for cid,names in chans:
        for dn in names:
            if dn == name:
                return cid
    short=canon_name(name)
    if not short: return None
    for cid,names in chans:
        joined=" ".join(n for n in names if n)
        if short and short in canon_name(joined):
            return cid
    return None

def parse_dt(s):
    if not s: return None
    for fmt in ("%Y%m%d%H%M%S %z","%Y%m%d%H%M%S%z"):
        try:
            return datetime.strptime(s,fmt).astimezone()
        except Exception:
            continue
    return None

cid = find_channel_id(playlist_name)
if not cid: sys.exit(0)

progs=[p for p in root.findall("programme") if p.get("channel")==cid]
now=datetime.now().astimezone()
start_day=now.replace(hour=0,minute=0,second=0,microsecond=0)
end_day=start_day+timedelta(days=1)

rows=[]
for p in progs:
    st=parse_dt(p.get("start"))
    en=parse_dt(p.get("stop"))
    if not st or not en: continue
    if en<=start_day or st>=end_day: continue
    t_el=p.find("title")
    title=(t_el.text.strip() if (t_el is not None and t_el.text) else "")
    if not title: continue
    st_clip=max(st,start_day)
    en_clip=min(en,end_day)
    rows.append((st_clip,en_clip,title))

rows.sort(key=lambda r:r[0])

def human_label(st,en):
    return f"{st.strftime('%-I:%M %p')}-{en.strftime('%-I:%M %p')}"

with open(map_path,"w",encoding="utf-8") as mf:
    for st,en,title in rows:
        key=(st.strftime("%-I:%M%p")+"-"+en.strftime("%-I:%M%p")).lower().replace(" ","")
        label=human_label(st,en)
        mf.write(f"{key}\t{int(st.timestamp())}\t{int(en.timestamp())}\t{label}\t{title}\n")

for st,en,title in rows:
    print(f"  {human_label(st,en)}  {title}")
PY

  echo
  echo "record 6:30pm-7:00pm   â†’ schedule that block"
  echo "record all Family Guy  â†’ series timer"
  echo "ENTER                   â†’ back"
  echo

  while true; do
    local CMD
    read -rp "daily-guide> " CMD
    [ -z "$CMD" ] && break
    case "$CMD" in
      [Rr]ecord\ all\ *)
        local TITLE
        TITLE=${CMD#*[Rr]ecord all }
        TITLE=$(echo "$TITLE" | sed 's/^ *//;s/ *$//')
        [ -z "$TITLE" ] && { echo "Need show name."; continue; }
        add_series_timer "$NUM" "$TITLE"
        ;;
      [Rr]ecord\ *)
        local ARG KEY INFO ST_TS EN_TS LABEL TITLE
        ARG=${CMD#*[Rr]ecord }
        KEY=$(echo "$ARG" | tr -d ' ' | tr 'A-Z' 'a-z')
        [ -z "$KEY" ] && { echo "Need time range."; continue; }
        INFO=$(awk -F'\t' -v k="$KEY" '$1==k{print;exit}' "$MAP")
        [ -z "$INFO" ] && { echo "No matching time block."; continue; }
        IFS=$'\t' read -r _ ST_TS EN_TS LABEL TITLE <<< "$INFO"
        schedule_record_block "$URL" "$NAME" "$TITLE" "$ST_TS" "$EN_TS" "$LABEL"
        ;;
      *)
        echo "Use: record HH:MMam-HH:MMpm or record all Name"
        ;;
    esac
  done

  rm -f "$MAP"
}

#########################################
# RECORDINGS FOLDER
#########################################
open_recordings() {
  echo ">>> Opening $RECDIR"
  if command -v thunar >/dev/null 2>&1; then
    thunar "$RECDIR" >/dev/null 2>&1 &
  elif command -v xdg-open >/dev/null 2>&1; then
    xdg-open "$RECDIR" >/dev/null 2>&1 &
  else
    echo "Open manually: $RECDIR"
  fi
  read -rp "ENTER to return..." _
}

#########################################
# CHANNEL LIST (PRINT + CLICK)
#########################################
print_channel_list() {
  local TABLE="$1"
  if [ -f "$NOW_CACHE" ]; then
    awk -F'\t' '
      FNR==NR { now[$1]=$3; next }
      {
        num=$1; name=$2
        if (num=="") next
        if (num in now)
          printf "[%3s] ðŸ“º %-30s \033[92m%.40s\033[0m\n", num, name, now[num]
        else
          printf "[%3s] ðŸ“º %s\n", num, name
      }
    ' "$NOW_CACHE" "$TABLE"
  else
    awk -F'\t' '
      {
        num=$1; name=$2
        if (num=="") next
        printf "[%3s] ðŸ“º %s\n", num, name
      }
    ' "$TABLE"
  fi
}

choose_channel_clickable() {
  local TABLE="$1"
  if ! command -v fzf >/dev/null 2>&1; then
    echo "fzf not installed; no clickable mode."
    read -rp "ENTER..." _
    return 1
  fi
  local choice
  choice=$(
    print_channel_list "$TABLE" |
    fzf --ansi \
        --prompt="TV â–¸ TVpass â–¸ Channels > " \
        --header="Use mouse or arrows, ENTER to tune, ESC to cancel" \
        --height=100% --reverse --border
  )
  [ -z "$choice" ] && return 1
  echo "$choice" | sed 's/^\[\s*\([0-9]\+\)\].*/\1/' 2>/dev/null
}

#########################################
# IPTV-ORG GLOBAL (CLICKABLE)
#########################################
iptv_ensure_playlist() {
  local file="$1" url="$2" label="$3"
  if [ -s "$file" ]; then return 0; fi
  echo ">>> Downloading $label..."
  curl -sS -L "$url" -o "$file"
}

iptv_build_tmp_from_playlist() {
  local src="$1" tmp="$2"
  awk -v OFS='\t' '
    BEGIN{name=""}
    /^#EXTINF/{
      name=$0
      sub(/.*,/,"",name)
      next
    }
    /^https?:\/\//{
      if (name=="") name="Unknown"
      print name,$0
      name=""
    }
  ' "$src" > "$tmp"
}

iptv_play_channel() {
  local IDX="$1" TABLE="$2" LAST NAME URL
  LAST=$(awk 'END{print NR}' "$TABLE")
  while true; do
    NAME=$(awk -F'\t' -v i="$IDX" 'NR==i{print $1}' "$TABLE")
    URL=$(awk -F'\t' -v i="$IDX" 'NR==i{print $2}' "$TABLE")

    clear
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘ TV â–¸ Global â–¸ Watching                 â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "\e[96mâ–¶ Global: $NAME\e[0m"
    echo
    recording_active && echo -e "   \e[91mâ— LIVE RECORDING (1/r to stop)\e[0m\n"
    echo "   Ctrl+Up/Down â†’ surf | 1/r â†’ live rec | q/Esc â†’ back"
    echo

    [ -z "$URL" ] && { echo "No URL"; read -rp "ENTER..." _; break; }

    mpv --fullscreen --input-conf="$INPUT_CONF" "$URL"
    local code=$?
    case "$code" in
      3) IDX=$((IDX+1)); [ "$IDX" -gt "$LAST" ] && IDX=1 ;;
      4) IDX=$((IDX-1)); [ "$IDX" -lt 1 ] && IDX="$LAST" ;;
      5) toggle_recording "$URL" "$NAME" "" ;;
      *) break ;;
    esac
  done
}

iptv_menu_clickable() {
  local TMP="$1" LABEL="$2"
  if ! command -v fzf >/dev/null 2>&1; then
    echo "fzf required for clickable global menu."
    read -rp "ENTER..." _
    return
  fi
  if [ ! -s "$TMP" ]; then
    echo "No channels in $LABEL."
    read -rp "ENTER..." _
    return
  fi

  local choice idx
  choice=$(
    awk -F'\t' '{
      n=NR
      printf "[%4d] ðŸŒ %s\n", n, $1
    }' "$TMP" |
    fzf --ansi \
        --prompt="TV â–¸ Global â–¸ $LABEL > " \
        --header="Click a channel, ENTER to play, ESC to back" \
        --height=100% --reverse --border
  )
  [ -z "$choice" ] && return
  idx=$(echo "$choice" | sed 's/^\[\s*\([0-9]\+\)\].*/\1/')
  [ -z "$idx" ] && return
  iptv_play_channel "$idx" "$TMP"
}

iptv_main_us() {
  iptv_ensure_playlist "$MAIN_PLAYLIST" "$MAIN_URL" "US main"
  local TMP
  TMP=$(mktemp)
  iptv_build_tmp_from_playlist "$MAIN_PLAYLIST" "$TMP"
  iptv_menu_clickable "$TMP" "US"
  rm -f "$TMP"
}

iptv_global_language_menu() {
  while true; do
    if ! command -v fzf >/dev/null 2>&1; then
      echo "fzf required for clickable language menu."
      read -rp "ENTER..." _
      return
    fi
    local choice
    choice=$(
      printf '%s\n' \
        "[1] ðŸŒ All languages" \
        "[2] ðŸ‡ºðŸ‡¸ English" \
        "[3] ðŸ‡ªðŸ‡¸ Spanish" \
        "[4] ðŸ‡«ðŸ‡· French" \
        "[5] ðŸ‡©ðŸ‡ª German" \
        "[6] ðŸ‡®ðŸ‡¹ Italian" \
        "[7] ðŸ‡µðŸ‡¹ Portuguese" \
        "[8] ðŸ‡·ðŸ‡º Russian" \
        "[9] ðŸ‡¸ðŸ‡¦ Arabic" \
        "[10] ðŸ‡¨ðŸ‡³ Chinese" \
        "[11] ðŸ‡¯ðŸ‡µ Japanese" \
        "[12] ðŸ‡°ðŸ‡· Korean" \
        "[13] ðŸ‡®ðŸ‡³ Hindi" \
        "[14] â¬… Back" |
      fzf --ansi \
          --prompt="TV â–¸ Global â–¸ Languages > " \
          --header="Pick a language group" \
          --height=100% --reverse --border
    )
    [ -z "$choice" ] && return
    case "$choice" in
      *"[1]"*)  SRC_URL="$GLOBAL_INDEX_URL"; SRC_FILE="$GLOBAL_INDEX"; LANG_LABEL="All" ;;
      *"[2]"*)  SRC_URL="https://iptv-org.github.io/iptv/languages/eng.m3u"; SRC_FILE="$TV_DIR/global-eng.m3u"; LANG_LABEL="English" ;;
      *"[3]"*)  SRC_URL="https://iptv-org.github.io/iptv/languages/spa.m3u"; SRC_FILE="$TV_DIR/global-spa.m3u"; LANG_LABEL="Spanish" ;;
      *"[4]"*)  SRC_URL="https://iptv-org.github.io/iptv/languages/fra.m3u"; SRC_FILE="$TV_DIR/global-fra.m3u"; LANG_LABEL="French" ;;
      *"[5]"*)  SRC_URL="https://iptv-org.github.io/iptv/languages/deu.m3u"; SRC_FILE="$TV_DIR/global-deu.m3u"; LANG_LABEL="German" ;;
      *"[6]"*)  SRC_URL="https://iptv-org.github.io/iptv/languages/ita.m3u"; SRC_FILE="$TV_DIR/global-ita.m3u"; LANG_LABEL="Italian" ;;
      *"[7]"*)  SRC_URL="https://iptv-org.github.io/iptv/languages/por.m3u"; SRC_FILE="$TV_DIR/global-por.m3u"; LANG_LABEL="Portuguese" ;;
      *"[8]"*)  SRC_URL="https://iptv-org.github.io/iptv/languages/rus.m3u"; SRC_FILE="$TV_DIR/global-rus.m3u"; LANG_LABEL="Russian" ;;
      *"[9]"*)  SRC_URL="https://iptv-org.github.io/iptv/languages/ara.m3u"; SRC_FILE="$TV_DIR/global-ara.m3u"; LANG_LABEL="Arabic" ;;
      *"[10]"*) SRC_URL="https://iptv-org.github.io/iptv/languages/zho.m3u"; SRC_FILE="$TV_DIR/global-zho.m3u"; LANG_LABEL="Chinese" ;;
      *"[11]"*) SRC_URL="https://iptv-org.github.io/iptv/languages/jpn.m3u"; SRC_FILE="$TV_DIR/global-jpn.m3u"; LANG_LABEL="Japanese" ;;
      *"[12]"*) SRC_URL="https://iptv-org.github.io/iptv/languages/kor.m3u"; SRC_FILE="$TV_DIR/global-kor.m3u"; LANG_LABEL="Korean" ;;
      *"[13]"*) SRC_URL="https://iptv-org.github.io/iptv/languages/hin.m3u"; SRC_FILE="$TV_DIR/global-hin.m3u"; LANG_LABEL="Hindi" ;;
      *"[14]"*) return ;;
      *) continue ;;
    esac
    echo ">>> Loading $LANG_LABEL..."
    curl -sS -L "$SRC_URL" -o "$SRC_FILE" || { echo "Failed."; read -rp "ENTER..." _; continue; }
    local TMP
    TMP=$(mktemp)
    iptv_build_tmp_from_playlist "$SRC_FILE" "$TMP"
    iptv_menu_clickable "$TMP" "$LANG_LABEL"
    rm -f "$TMP"
  done
}

iptv_search() {
  iptv_ensure_playlist "$GLOBAL_INDEX" "$GLOBAL_INDEX_URL" "global index"
  local TMP
  TMP=$(mktemp)
  iptv_build_tmp_from_playlist "$GLOBAL_INDEX" "$TMP"

  clear
  echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
  echo "â•‘ TV â–¸ Global â–¸ Search                   â•‘"
  echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  read -rp "Search term: " Q
  [ -z "$Q" ] && { rm -f "$TMP"; return; }

  local S_TMP
  S_TMP=$(mktemp)
  while IFS=$'\t' read -r name url; do
    if printf '%s\n' "$name" | grep -iF -- "$Q" >/dev/null 2>&1; then
      printf '%s\t%s\n' "$name" "$url" >> "$S_TMP"
    fi
  done < "$TMP"

  if [ ! -s "$S_TMP" ]; then
    echo "No matches."
    rm -f "$TMP" "$S_TMP"
    read -rp "ENTER..." _
    return
  fi
  iptv_menu_clickable "$S_TMP" "search: $Q"
  rm -f "$TMP" "$S_TMP"
}

iptv_top_menu() {
  while true; do
    if ! command -v fzf >/dev/null 2>&1; then
      echo "fzf needed for clickable global menu."
      read -rp "ENTER..." _
      return
    fi
    local choice
    choice=$(
      printf '%s\n' \
        "[1] ðŸ“º US main list" \
        "[2] ðŸŒ Global by language" \
        "[3] ðŸ” Global search" \
        "[4] â¬… Back" |
      fzf --ansi \
          --prompt="TV â–¸ Global > " \
          --header="Pick a global mode" \
          --height=100% --reverse --border
    )
    [ -z "$choice" ] && return
    case "$choice" in
      *"[1]"*) iptv_main_us ;;
      *"[2]"*) iptv_global_language_menu ;;
      *"[3]"*) iptv_search ;;
      *"[4]"*) return ;;
    esac
  done
}

#########################################
# QUICK GUIDE LIST (G)
#########################################
guide_mode() {
  clear
  echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
  echo "â•‘ TV â–¸ TVpass â–¸ Quick Guide              â•‘"
  echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo
  if [ -f "$GUIDE_CACHE" ]; then
    cat "$GUIDE_CACHE"
  else
    echo "No guide cache."
  fi
  echo
  read -rp "Channel # (or ENTER): " choice
  if [ -n "$choice" ] && printf '%s\n' "$choice" | grep -Eq '^[0-9]+$'; then
    play_channel "$choice" "$TABLE"
  fi
}

#########################################
# MAIN CLICKABLE MENU
#########################################
main_menu_clickable() {
  while true; do
    if ! command -v fzf >/dev/null 2>&1; then
      # fallback: text prompt
      clear
      echo "TV Main Menu (fzf missing)"
      echo "1) TVpass Channels"
      echo "2) Quick Guide"
      echo "3) Global"
      echo "4) Recordings"
      echo "5) Timers list"
      echo "6) Timers scan"
      echo "7) Quit"
      read -rp "> " ch
      case "$ch" in
        1) SEL=$(choose_channel_clickable "$TABLE") || true; [ -n "$SEL" ] && play_channel "$SEL" "$TABLE" ;;
        2) guide_mode ;;
        3) iptv_top_menu ;;
        4) open_recordings ;;
        5) clear; timers_list; read -rp "ENTER..." _ ;;
        6) clear; timers_scan; read -rp "ENTER..." _ ;;
        7) break ;;
      esac
      continue
    fi

    local choice
    choice=$(
      printf '%s\n' \
        "[1] ðŸ“º  TVpass Channels" \
        "[2] ðŸ—“ï¸  Quick Guide" \
        "[3] ðŸŒ  Global Channels" \
        "[4] ðŸ“‚  Recordings" \
        "[5] â±ï¸  Timers (list)" \
        "[6] ðŸ”  Timers (scan EPG)" \
        "[7] âŒ  Quit" |
      fzf --ansi \
          --prompt="TV â–¸ Main > " \
          --header="Use mouse or arrows, ENTER to select" \
          --height=100% --reverse --border
    )
    [ -z "$choice" ] && break
    case "$choice" in
      *"[1]"*) SEL=$(choose_channel_clickable "$TABLE") || true; [ -n "$SEL" ] && play_channel "$SEL" "$TABLE" ;;
      *"[2]"*) guide_mode ;;
      *"[3]"*) iptv_top_menu ;;
      *"[4]"*) open_recordings ;;
      *"[5]"*) clear; echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"; echo "â•‘ TV â–¸ Timers â–¸ Listâ•‘"; echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"; timers_list; read -rp "ENTER..." _ ;;
      *"[6]"*) clear; echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"; echo "â•‘ TV â–¸ Timers â–¸ ScanEPGâ•‘"; echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"; timers_scan; read -rp "ENTER..." _ ;;
      *"[7]"*) break ;;
    esac
  done
}

#########################################
# ENTRYPOINT
#########################################
prevent_sleep
ensure_deps
ensure_input_conf
tvpass_ensure_playlist
tvpass_ensure_guide
detect_storage_tier

case "$1" in
  update) tvpass_update_all ;;
  guide|G|g)
    echo ">>> Building guide..."
    TABLE=$(build_table)
    build_guide_cache "$TABLE"
    guide_mode
    rm -f "$TABLE"
    exit 0
    ;;
  timers-scan) timers_scan; exit 0 ;;
  timers-list) timers_list; exit 0 ;;
esac

show_disclaimer

echo ">>> Building TVpass channel table + guide..."
TABLE=$(build_table)
build_guide_cache "$TABLE"

iptv_ensure_playlist "$MAIN_PLAYLIST" "$MAIN_URL" "US main" >/dev/null 2>&1 || true
iptv_ensure_playlist "$GLOBAL_INDEX" "$GLOBAL_INDEX_URL" "global index" >/dev/null 2>&1 || true

echo "Storage: $STORAGE_TIER | background recordings: $MAX_BG_RECORDINGS | live: $MAX_LIVE_RECORDINGS"
sleep 1

main_menu_clickable

rm -f "$TABLE"
TVEOF

chmod +x "$HOME/.local/bin/tv"
echo ">>> TV 4.1 installed. Run: tv"
EOF
