cat > "$HOME/.local/bin/tv" << 'EOF'
#!/usr/bin/env bash
# TV 3.12 Runtime
# - Guide only shows channels with EPG, as 4 upcoming time blocks
# - Main screen shows current title under each channel (1 line)
# - Tuning + surfing show NOW / NEXT / AFTER / LATER (titles only)
# - Uses system local time to decide what's upcoming
# - Ctrl+Alt+R recording toggle with messages
# - Recordings saved under recordings/<Channel>/<YYYY-MM-DD>/Channel[_Show]_YYYY-MM-DD_HH-MM-SS.ts
# - Channels >=178 removed (sports block)
# - 'h' = help, 'recordings' opens DVR folder in file manager

PLAYLIST="$HOME/TV/playlist.m3u"
EPG="$HOME/TV/epg.xml"
TVPASS_PLS="https://tvpass.org/playlist/m3u"
TVPASS_EPG="https://tvpass.org/epg.xml"
INPUT_CONF="$HOME/TV/tv-input.conf"
RECDIR="$HOME/TV/recordings"
REC_PIDFILE="$HOME/TV/recording.pid"
GUIDE_CACHE="$HOME/TV/guide-cache.txt"
NOW_CACHE="$HOME/TV/now-cache.txt"
EPG4_CACHE="$HOME/TV/epg-four.txt"

mkdir -p "$RECDIR"

#####################################
### INPUT CONF FOR MPV SURF BINDINGS
### (always rewrite so bindings stay in sync)
#####################################
ensure_input_conf() {
  cat > "$INPUT_CONF" << 'EOT'
ctrl+UP no-osd quit 3
ctrl+DOWN no-osd quit 4
ctrl+alt+r no-osd quit 5
EOT
}

#########################################
### PLAYLIST + EPG ENSURE / UPDATE
#########################################
ensure_playlist() {
  if [ ! -f "$PLAYLIST" ] || [ ! -s "$PLAYLIST" ]; then
    echo ">>> Downloading playlist..."
    curl -L "$TVPASS_PLS" -o "$PLAYLIST"
  fi
}

ensure_epg() {
  if [ ! -f "$EPG" ] || [ ! -s "$EPG" ]; then
    echo ">>> Downloading EPG..."
    curl -L "$TVPASS_EPG" -o "$EPG"
  fi
}

update_all() {
  echo "Updating playlist + EPG..."
  curl -L "$TVPASS_PLS" -o "$PLAYLIST"
  curl -L "$TVPASS_EPG" -o "$EPG"
  echo "✔ Updated."
  exit 0
}

#########################################
### PARSE PLAYLIST INTO TEMP TABLE
### (Drop channels 178+)
#########################################
build_table() {
  local TMP
  TMP=$(mktemp)
  awk -v OFS='\t' '
    BEGIN{n=0; name=""}
    /^#EXTINF/{
      sub(/.*,/, "", $0); name=$0; next
    }
    /^http/{
      if (n >= 177) next;   # drop everything from 178 onward
      n++; print n, (name==""?"Unknown":name), $0; name=""
    }
  ' "$PLAYLIST" > "$TMP"
  echo "$TMP"
}

#########################################
### BUILD GUIDE / NOW / FOUR-CACHE VIA PYTHON
### Uses local time; picks first 4 programmes with stop > now
#########################################
build_guide_cache() {
  local TABLE="$1"
  : > "$GUIDE_CACHE"
  : > "$NOW_CACHE"
  : > "$EPG4_CACHE"

  python3 - "$EPG" "$TABLE" "$GUIDE_CACHE" "$NOW_CACHE" "$EPG4_CACHE" << 'PY'
import sys, re
from datetime import datetime
import xml.etree.ElementTree as ET

epg_path, table_path, guide_path, now_path, four_path = sys.argv[1:]

tree = ET.parse(epg_path)
root = tree.getroot()

channels = []
for ch in root.findall("channel"):
    cid = ch.get("id", "")
    names = [dn.text.strip() for dn in ch.findall("display-name") if dn.text]
    channels.append((cid, names))

def canon_name(s: str) -> str:
    s = s or ""
    for token in ["HD", "East", "West", "US", "Feed"]:
        s = re.sub(r"\b" + re.escape(token) + r"\b", "", s, flags=re.I)
    s = re.sub(r"\s+", " ", s).strip().lower()
    return s

def find_channel_id(playlist_name: str):
    name = (playlist_name or "").strip()
    if not name:
        return None
    # exact
    for cid, names in channels:
        for dn in names:
            if dn == name:
                return cid
    # fuzzy
    short = canon_name(name)
    if not short:
        return None
    for cid, names in channels:
        joined = " ".join(n for n in names if n).lower()
        if short and short in joined:
            return cid
    return None

progs_by_id = {}
for p in root.findall("programme"):
    cid = p.get("channel")
    if not cid:
        continue
    progs_by_id.setdefault(cid, []).append(p)

def parse_dt(s: str):
    if not s:
        return None
    for fmt in ("%Y%m%d%H%M%S %z", "%Y%m%d%H%M%S%z"):
        try:
            return datetime.strptime(s, fmt).astimezone()
        except Exception:
            continue
    return None

now = datetime.now().astimezone()

def blocks_from_now(cid: str):
    """Return up to 4 (start, stop, title) blocks from 'now' onward."""
    progs = progs_by_id.get(cid, [])
    if not progs:
        return []
    out = []
    for p in progs:
        start = parse_dt(p.get("start"))
        stop = parse_dt(p.get("stop"))
        if not stop or not start:
            continue
        if stop > now:
            t_el = p.find("title")
            title = t_el.text.strip() if (t_el is not None and t_el.text) else ""
            if title:
                out.append((start, stop, title))
        if len(out) >= 4:
            break
    return out

with open(table_path, "r", encoding="utf-8") as tf, \
     open(guide_path, "w", encoding="utf-8") as gf, \
     open(now_path, "w", encoding="utf-8") as nf, \
     open(four_path, "w", encoding="utf-8") as ff:

    for line in tf:
        parts = line.rstrip("\n").split("\t")
        if len(parts) < 3:
            continue
        num, name, url = parts[0], parts[1], parts[2]
        if not num:
            continue

        cid = find_channel_id(name)
        if not cid:
            continue

        blocks = blocks_from_now(cid)
        if not blocks:
            continue

        # titles list for NOW-cache + EPG4-cache
        titles = [b[2] for b in blocks]

        # NOW cache for main list
        nf.write(f"{num}\t{name}\t{titles[0]}\n")

        # 4-pack titles (for info overlay while watching)
        four_titles = titles + [""] * (4 - len(titles))
        ff.write(f"{num}\t" + "\t".join(four_titles[:4]) + "\n")

        # Human guide: time block in local time + title
        gf.write(f"\x1b[96m{num}. {name}\x1b[0m\n")
        for start, stop, title in blocks:
            # Local time strings, e.g. 6:30 PM-7:00 PM
            tstr = f"{start.strftime('%-I:%M %p')}-{stop.strftime('%-I:%M %p')}"
            gf.write(f"   {tstr}  {title}\n")
        gf.write("\n")
PY
}

#########################################
### LOOK UP NOW-TITLE BY CHANNEL NUMBER
#########################################
now_title_for_num() {
  local num="$1"
  [ -f "$NOW_CACHE" ] || return
  awk -F'\t' -v n="$num" '$1==n{print $3; exit}' "$NOW_CACHE" 2>/dev/null
}

#########################################
### SURF INFO BLOCK: NOW / NEXT / AFTER / LATER (titles)
#########################################
epg_now_next_block() {
  local num="$1"
  [ -f "$EPG4_CACHE" ] || return
  local line
  line=$(awk -F'\t' -v n="$num" '$1==n{print; exit}' "$EPG4_CACHE" 2>/dev/null)
  [ -z "$line" ] && return

  IFS=$'\t' read -r _ NOW NEXT AFTER LATER <<< "$line"

  if [ -n "$NOW" ]; then
    echo -e "   \e[91mNOW: $NOW\e[0m"
  fi
  [ -n "$NEXT" ]  && echo "   NEXT:  $NEXT"
  [ -n "$AFTER" ] && echo "   AFTER: $AFTER"
  [ -n "$LATER" ] && echo "   LATER: $LATER"
}

#########################################
### DVR — TOGGLE RECORDING
#########################################
recording_active() {
  [ -f "$REC_PIDFILE" ] || return 1
  local pid
  pid=$(cat "$REC_PIDFILE" 2>/dev/null || echo "")
  [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null
}

start_recording() {
  local url="$1"
  local chan="$2"
  local show="$3"

  # Clean names for filesystem
  local chsafe showsafe
  chsafe=$(echo "$chan" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  [ -z "$chsafe" ] && chsafe="Channel"
  if [ -n "$show" ]; then
    showsafe=$(echo "$show" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  fi

  local day ts dir outfile
  day=$(date +"%Y-%m-%d")
  ts=$(date +"%Y-%m-%d_%H-%M-%S")
  dir="$RECDIR/$chsafe/$day"
  mkdir -p "$dir"

  if [ -n "$showsafe" ]; then
    outfile="$dir/${chsafe}_${showsafe}_$ts.ts"
  else
    outfile="$dir/${chsafe}_$ts.ts"
  fi

  echo ">>> Recording started → $outfile"
  ffmpeg -nostdin -y -i "$url" -c copy "$outfile" >/dev/null 2>&1 &
  echo $! > "$REC_PIDFILE"
}

stop_recording() {
  local pid
  pid=$(cat "$REC_PIDFILE" 2>/dev/null || echo "")
  if [ -n "$pid" ]; then
    kill "$pid" 2>/dev/null || true
    wait "$pid" 2>/dev/null || true
  fi
  rm -f "$REC_PIDFILE"
  echo ">>> Recording stopped."
}

toggle_recording() {
  local url="$1"
  local chan="$2"
  local num="$3"   # channel number (for current show lookup)

  if recording_active; then
    stop_recording
  else
    local show=""
    if [ -n "$num" ]; then
      show=$(now_title_for_num "$num")
    fi
    start_recording "$url" "$chan" "$show"
  fi
}

#########################################
### PLAY CHANNEL WITH SURFING
#########################################
play_channel() {
  local CUR="$1"
  local TABLE="$2"
  local LAST
  LAST=$(awk -F'\t' 'END{print $1}' "$TABLE")

  while true; do
    local NAME URL
    NAME=$(awk -F'\t' -v i="$CUR" '$1==i{print $2}' "$TABLE")
    URL=$(awk -F'\t' -v i="$CUR" '$1==i{print $3}' "$TABLE")

    clear
    echo -e "\e[96m▶ CHANNEL $CUR: $NAME\e[0m"
    echo
    epg_now_next_block "$CUR"
    echo

    if recording_active; then
      echo -e "   \e[91m● RECORDING ACTIVE (Ctrl+Alt+R to stop)\e[0m"
      echo
    fi

    echo "   Ctrl+Up / Ctrl+Down → Surf channels"
    echo "   Ctrl+Alt+R          → Toggle recording"
    echo "   q / ESC             → Exit to channel list"
    echo

    mpv --fullscreen --input-conf="$INPUT_CONF" "$URL"
    local code=$?

    case "$code" in
      3)
        CUR=$((CUR+1))
        [ "$CUR" -gt "$LAST" ] && CUR=1
        ;;
      4)
        CUR=$((CUR-1))
        [ "$CUR" -lt 1 ] && CUR="$LAST"
        ;;
      5)
        toggle_recording "$URL" "$NAME" "$CUR"
        ;;
      *)
        break
        ;;
    esac
  done
}

#########################################
### GUIDE MODE ("G") — USE PREBUILT CACHE
#########################################
guide_mode() {
  clear
  echo -e "\e[93m==================== TV GUIDE ====================\e[0m"
  echo " Next 4 upcoming blocks per channel (local time)."
  echo " Enter a channel number to tune, or just ENTER to return."
  echo

  if [ -f "$GUIDE_CACHE" ]; then
    cat "$GUIDE_CACHE"
  else
    echo "Guide cache not built yet."
  fi

  local choice
  read -rp "Channel #: " choice
  if [ -n "$choice" ] && printf '%s\n' "$choice" | grep -Eq '^[0-9]+$'; then
    play_channel "$choice" "$TABLE"
  fi
}

#########################################
### HELP SCREEN
#########################################
help_screen() {
  clear
  echo -e "\e[96m============== TV HELP ==============\e[0m"
  echo
  echo " Main screen:"
  echo "   • Enter a number → tune channel"
  echo "   • G              → open quick guide (4 upcoming blocks/channel)"
  echo "   • h              → this help screen"
  echo "   • recordings     → open DVR recordings folder"
  echo "   • ENTER on blank → exit TV"
  echo
  echo " While watching:"
  echo "   • Ctrl+Up / Ctrl+Down → surf channels"
  echo "   • Ctrl+Alt+R          → toggle recording for current channel/show"
  echo "   • q / ESC             → back to channel list"
  echo
  echo " Recordings layout:"
  echo "   $RECDIR/<Channel>/<YYYY-MM-DD>/<Channel[_Show]_YYYY-MM-DD_HH-MM-SS>.ts"
  echo
  read -rp "Press ENTER to return to channel list..." _
}

#########################################
### OPEN RECORDINGS FOLDER
#########################################
open_recordings() {
  echo ">>> Opening recordings folder: $RECDIR"
  if command -v xdg-open >/dev/null 2>&1; then
    xdg-open "$RECDIR" >/dev/null 2>&1 &
  else
    echo "xdg-open not found. Open this path manually:"
    echo "  $RECDIR"
  fi
  read -rp "Press ENTER to return to channel list..." _
}

#########################################
### PRINT CHANNEL LIST WITH CURRENT SHOW
#########################################
print_channel_list() {
  local TABLE="$1"
  while IFS=$'\t' read -r num name url; do
    [ -z "$num" ] && continue
    local nowt
    nowt=$(now_title_for_num "$num")
    if [ -n "$nowt" ]; then
      printf "%-4s %s  \e[92m%s\e[0m\n" "$num" "$name" "${nowt:0:40}"
    else
      printf "%-4s %s\n" "$num" "$name"
    fi
  done < "$TABLE"
}

#########################################
### MAIN MENU
#########################################
ensure_input_conf
ensure_playlist
ensure_epg

echo ">>> Building channel list and TV guide..."
TABLE=$(build_table)
build_guide_cache "$TABLE"
echo ">>> Guide ready. Launching TV..."
sleep 1

case "$1" in
  update) update_all ;;
  guide|G|g) guide_mode ;;
  *)
    while true; do
      clear
      echo -e "\e[92m==================== TV CHANNELS ====================\e[0m"
      echo " Enter number to play | G = guide | h = help |"
      echo " Type 'recordings' to open DVR folder | ENTER to exit"
      echo
      print_channel_list "$TABLE"
      echo
      read -rp "Channel #: " CH

      [ -z "$CH" ] && break

      case "$CH" in
        [Gg])
          guide_mode
          continue
          ;;
        [Hh])
          help_screen
          continue
          ;;
        recordings)
          open_recordings
          continue
          ;;
      esac

      if ! printf '%s\n' "$CH" | grep -Eq '^[0-9]+$'; then
        continue
      fi

      play_channel "$CH" "$TABLE"
    done

    rm -f "$TABLE"
    ;;
esac
EOF

chmod +x "$HOME/.local/bin/tv"
echo ">>> TV 3.12 patched. Run: tv"
