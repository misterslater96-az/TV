cat > "$HOME/.local/bin/tv" << 'EOF'
#!/usr/bin/env bash
# TV 3.70 Runtime
# - TVpass curated list + program guide (what's on now / next)
# - Green "now playing" text on main list
# - DVR: live toggle + scheduled from daily guide
# - 'more' ‚Üí iptv-org global: fullscreen, surfing, 1/r to record
# - mpv/ffmpeg spam hidden, curl quiet
# - Thunar auto-installed (with mpv + curl) on apt systems for Chromebook/Crostini
# - Chromebook-friendly: 1 or r toggles recording

#########################################
### PATHS / GLOBALS
#########################################
TV_DIR="$HOME/TV"

# TVpass (curated main list)
PLAYLIST="$TV_DIR/playlist.m3u"
EPG="$TV_DIR/epg.xml"
TVPASS_PLS="https://tvpass.org/playlist/m3u"
TVPASS_EPG="https://tvpass.org/epg.xml"
INPUT_CONF="$TV_DIR/tv-input.conf"
RECDIR="$TV_DIR/recordings"
REC_PIDFILE="$TV_DIR/recording.pid"
GUIDE_CACHE="$TV_DIR/guide-cache.txt"
NOW_CACHE="$TV_DIR/now-cache.txt"
EPG4_CACHE="$TV_DIR/epg-four.txt"
NAME_NOW_CACHE="$TV_DIR/now-by-name.txt"   # canonical name ‚Üí "now playing" title

# iptv-org (huge global lists)
MAIN_PLAYLIST="$TV_DIR/main.m3u"
GLOBAL_INDEX="$TV_DIR/global-index.m3u"
MAIN_URL="https://iptv-org.github.io/iptv/countries/us.m3u"
GLOBAL_INDEX_URL="https://iptv-org.github.io/iptv/index.m3u"

mkdir -p "$TV_DIR" "$RECDIR"

#########################################
### DEPENDENCIES (mpv, curl, thunar)
#########################################
ensure_deps() {
  local need_install=0

  command -v mpv    >/dev/null 2>&1 || need_install=1
  command -v curl   >/dev/null 2>&1 || need_install=1
  command -v thunar >/dev/null 2>&1 || need_install=1

  if [ "$need_install" -ne 1 ]; then
    return 0
  fi

  if ! command -v apt >/dev/null 2>&1; then
    echo "‚ö†Ô∏è  mpv, curl and thunar are recommended."
    echo "    Please install them with your distro's package manager."
    return 0
  fi

  echo ">>> üß∞ Installing mpv, curl, and thunar (needs sudo)..."
  sudo apt update
  sudo apt install -y mpv curl thunar
}

#########################################
### STARTUP DISCLAIMER
#########################################
show_disclaimer() {
  clear
  cat << 'EOD'
üì∫ TV 3.70 ‚Äì Welcome!

Basic controls:
  ‚Ä¢ On the main list:
      - Type a number and press ENTER ‚Üí open that channel
      - Type G and press ENTER        ‚Üí quick guide (what's on each channel)
      - Type G 12 and press ENTER     ‚Üí full-day guide for channel 12
      - Type more and press ENTER     ‚Üí huge world channel list üåç
      - Type recordings               ‚Üí open your saved recordings
      - Press ENTER on an empty line  ‚Üí quit

  ‚Ä¢ While a channel is playing:
      - Ctrl+Up / Ctrl+Down           ‚Üí move to next / previous channel
      - 1 or r                        ‚Üí start/stop recording the stream
      - q or ESC                      ‚Üí go back to the list

Program info:
  ‚Ä¢ The curated TV list (TVpass) has real ‚Äúwhat‚Äôs on now‚Äù data.
  ‚Ä¢ The giant global lists from iptv-org usually do NOT ship any
    schedule information. This script will *try* to reuse the TVpass
    guide where channel names line up, but most global channels will
    just show their names with no show titles.

EOD
  echo
  read -rp "Press ENTER to launch TV... " _
}

#####################################
### INPUT CONF FOR MPV SURF BINDINGS
#####################################
ensure_input_conf() {
  cat > "$INPUT_CONF" << 'EOT'
ctrl+UP no-osd quit 3
ctrl+DOWN no-osd quit 4
1 no-osd quit 5
r no-osd quit 5
EOT
}

#########################################
### TVPASS PLAYLIST + GUIDE ENSURE / UPDATE
#########################################
tvpass_ensure_playlist() {
  if [ ! -f "$PLAYLIST" ] || [ ! -s "$PLAYLIST" ]; then
    echo ">>> üì° Downloading TVpass channel list..."
    curl -sS -L "$TVPASS_PLS" -o "$PLAYLIST"
  fi
}

tvpass_ensure_guide() {
  if [ ! -f "$EPG" ] || [ ! -s "$EPG" ]; then
    echo ">>> üì° Downloading TVpass program guide..."
    curl -sS -L "$TVPASS_EPG" -o "$EPG"
  fi
}

tvpass_update_all() {
  echo "‚ü≥ Updating TVpass channel list + program guide..."
  curl -sS -L "$TVPASS_PLS" -o "$PLAYLIST"
  curl -sS -L "$TVPASS_EPG" -o "$EPG"
  echo "‚úî TVpass sources updated ‚úÖ"
  exit 0
}

#########################################
### TVPASS: PARSE PLAYLIST INTO TEMP TABLE
### (Drop channels 178+)
#########################################
build_table() {
  local TMP
  TMP=$(mktemp)
  awk -v OFS='\t' '
    BEGIN{n=0; name=""}
    /^#EXTINF/{
      sub(/.*,/, "", $0); name=$0; next
    }
    /^http/{
      if (n >= 177) next;   # drop everything from 178 onward
      n++; print n, (name==""?"Unknown":name), $0; name=""
    }
  ' "$PLAYLIST" > "$TMP"
  echo "$TMP"
}

#########################################
### TVPASS: BUILD GUIDE / NOW / FOUR-CACHE VIA PYTHON
### Also builds name-based map for reuse on global side
#########################################
build_guide_cache() {
  local TABLE="$1"
  : > "$GUIDE_CACHE"
  : > "$NOW_CACHE"
  : > "$EPG4_CACHE"
  : > "$NAME_NOW_CACHE"

  python3 - "$EPG" "$TABLE" "$GUIDE_CACHE" "$NOW_CACHE" "$EPG4_CACHE" "$NAME_NOW_CACHE" << 'PY'
import sys, re
from datetime import datetime
import xml.etree.ElementTree as ET

epg_path, table_path, guide_path, now_path, four_path, name_now_path = sys.argv[1:]

tree = ET.parse(epg_path)
root = tree.getroot()

def canon_name(s: str) -> str:
    s = s or ""
    # strip [720p], [Geo-blocked], etc
    s = re.sub(r"\[[^\]]*\]", " ", s)
    # strip (USA), (HD), etc
    s = re.sub(r"\([^)]*\)", " ", s)
    # remove punctuation-ish junk
    s = re.sub(r"[-‚Äì_|]", " ", s)
    # kill common filler words
    for token in ["HD", "East", "West", "US", "USA", "Feed",
                  "TV", "Channel", "Network", "Latino"]:
        s = re.sub(r"\b" + re.escape(token) + r"\b", " ", s, flags=re.I)
    s = re.sub(r"\s+", " ", s).strip().lower()
    return s

channels = []
for ch in root.findall("channel"):
    cid = ch.get("id", "")
    names = [dn.text.strip() for dn in ch.findall("display-name") if dn.text]
    channels.append((cid, names))

def find_channel_id(playlist_name: str):
    name = (playlist_name or "").strip()
    if not name:
        return None
    # exact match first
    for cid, names in channels:
        for dn in names:
            if dn == name:
                return cid
    # fuzzy via canonicalized name
    short = canon_name(name)
    if not short:
        return None
    for cid, names in channels:
        joined = " ".join(n for n in names if n)
        if short and short in canon_name(joined):
            return cid
    return None

progs_by_id = {}
for p in root.findall("programme"):
    cid = p.get("channel")
    if not cid:
        continue
    progs_by_id.setdefault(cid, []).append(p)

def parse_dt(s: str):
    if not s:
        return None
    for fmt in ("%Y%m%d%H%M%S %z", "%Y%m%d%H%M%S%z"):
        try:
            return datetime.strptime(s, fmt).astimezone()
        except Exception:
            continue
    return None

now = datetime.now().astimezone()

def blocks_from_now(cid: str):
    """Return up to 4 (start, stop, title) blocks from 'now' onward."""
    progs = progs_by_id.get(cid, [])
    if not progs:
        return []
    out = []
    for p in progs:
      start = parse_dt(p.get("start"))
      stop = parse_dt(p.get("stop"))
      if not stop or not start:
          continue
      if stop > now:
          t_el = p.find("title")
          title = t_el.text.strip() if (t_el is not None and t_el.text) else ""
          if title:
              out.append((start, stop, title))
      if len(out) >= 4:
          break
    return out

with open(table_path, "r", encoding="utf-8") as tf, \
     open(guide_path, "w", encoding="utf-8") as gf, \
     open(now_path, "w", encoding="utf-8") as nf, \
     open(four_path, "w", encoding="utf-8") as ff, \
     open(name_now_path, "w", encoding="utf-8") as nfname:

    seen_names = set()

    for line in tf:
        parts = line.rstrip("\n").split("\t")
        if len(parts) < 3:
            continue
        num, name, url = parts[0], parts[1], parts[2]
        if not num:
            continue

        cid = find_channel_id(name)
        if not cid:
            continue

        blocks = blocks_from_now(cid)
        if not blocks:
            continue

        titles = [b[2] for b in blocks]

        # NOW cache for main list
        nf.write(f"{num}\t{name}\t{titles[0]}\n")

        # Name-based cache (canonical) so global lists can reuse it
        key = canon_name(name)
        if key and key not in seen_names:
            nfname.write(f"{key}\t{titles[0]}\n")
            seen_names.add(key)

        # 4-pack titles (for info overlay while watching)
        four_titles = titles + [""] * (4 - len(titles))
        ff.write(f"{num}\t" + "\t".join(four_titles[:4]) + "\n")

        # Human-readable guide
        gf.write(f"\x1b[96m{num}. {name}\x1b[0m\n")
        for start, stop, title in blocks:
            tstr = f"{start.strftime('%-I:%M %p')}-{stop.strftime('%-I:%M %p')}"
            gf.write(f"   {tstr}  {title}\n")
        gf.write("\n")
PY
}

#########################################
### LOOK UP "NOW PLAYING"
#########################################
now_title_for_num() {
  local num="$1"
  [ -f "$NOW_CACHE" ] || return
  awk -F'\t' -v n="$num" '$1==n{print $3; exit}' "$NOW_CACHE" 2>/dev/null
}

canon_name_shell() {
  local s="$1"
  s="${s//[/ }"
  s="${s//]/ }"
  s="${s//(/ }"
  s="${s//)/ }"
  s=$(printf '%s' "$s" | tr 'A-Z' 'a-z')
  # trim punctuation-ish junk
  s=$(printf '%s\n' "$s" | sed 's/[-_|]/ /g')
  # remove common tokens
  for w in hd east west us usa feed tv channel network latino; do
    s=$(printf '%s\n' "$s" | sed "s/\b$w\b//g")
  done
  s=$(printf '%s\n' "$s" | tr -s ' ')
  s=$(printf '%s\n' "$s" | sed 's/^ *//;s/ *$//')
  printf '%s\n' "$s"
}

now_title_for_name() {
  local raw="$1"
  [ -f "$NAME_NOW_CACHE" ] || return
  local key
  key=$(canon_name_shell "$raw")
  [ -z "$key" ] && return
  awk -F'\t' -v k="$key" '$1==k{print $2; exit}' "$NAME_NOW_CACHE" 2>/dev/null
}

#########################################
### SURF INFO BLOCK: NOW / NEXT / AFTER / LATER
#########################################
epg_now_next_block() {
  local num="$1"
  [ -f "$EPG4_CACHE" ] || return
  local line
  line=$(awk -F'\t' -v n="$num" '$1==n{print; exit}' "$EPG4_CACHE" 2>/dev/null)
  [ -z "$line" ] && return

  IFS=$'\t' read -r _ NOW NEXT AFTER LATER <<< "$line"

  if [ -n "$NOW" ]; then
    echo -e "   \e[91mNOW: $NOW\e[0m"
  fi
  [ -n "$NEXT" ]  && echo "   NEXT:  $NEXT"
  [ -n "$AFTER" ] && echo "   AFTER: $AFTER"
  [ -n "$LATER" ] && echo "   LATER: $LATER"
}

#########################################
### DVR ‚Äî LIVE TOGGLE RECORDING
#########################################
recording_active() {
  [ -f "$REC_PIDFILE" ] || return 1
  local pid
  pid=$(cat "$REC_PIDFILE" 2>/dev/null || echo "")
  [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null
}

start_recording() {
  local url="$1"
  local chan="$2"
  local show="$3"

  local chsafe showsafe day ts dir outfile
  chsafe=$(echo "$chan" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  [ -z "$chsafe" ] && chsafe="Channel"
  if [ -n "$show" ]; then
    showsafe=$(echo "$show" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  fi

  day=$(date +"%Y-%m-%d")
  ts=$(date +"%Y-%m-%d_%H-%M-%S")
  dir="$RECDIR/$chsafe/$day"
  mkdir -p "$dir"

  if [ -n "$showsafe" ]; then
    outfile="$dir/${chsafe}_${showsafe}_$ts.ts"
  else
    outfile="$dir/${chsafe}_$ts.ts"
  fi

  echo ">>> üé• Recording started ‚Üí $outfile"
  ffmpeg -nostdin -y -i "$url" -c copy "$outfile" >/dev/null 2>&1 &
  echo $! > "$REC_PIDFILE"
}

stop_recording() {
  local pid
  pid=$(cat "$REC_PIDFILE" 2>/dev/null || echo "")
  if [ -n "$pid" ]; then
    kill "$pid" 2>/dev/null || true
    wait "$pid" 2>/dev/null || true
  fi
  rm -f "$REC_PIDFILE"
  echo ">>> üõë Recording stopped."
}

toggle_recording() {
  local url="$1"
  local chan="$2"
  local num="$3"   # TVpass channel number for current show lookup (empty for global)

  if recording_active; then
    stop_recording
  else
    local show=""
    if [ -n "$num" ]; then
      show=$(now_title_for_num "$num")
    fi
    start_recording "$url" "$chan" "$show"
  fi
}

#########################################
### SCHEDULED RECORDING FOR A TIME BLOCK
#########################################
schedule_record_block() {
  local url="$1"
  local chan="$2"
  local show="$3"
  local start_ts="$4"
  local end_ts="$5"
  local label="$6"

  local now_ts duration delay
  now_ts=$(date +%s)
  duration=$((end_ts - start_ts))
  if [ "$duration" -le 0 ]; then
    echo "Block has zero or negative duration, not scheduling."
    return
  fi
  delay=$((start_ts - now_ts))
  if [ "$delay" -lt 0 ]; then
    delay=0
    duration=$((end_ts - now_ts))
    [ "$duration" -le 0 ] && { echo "Block already finished."; return; }
  fi

  local chsafe showsafe day ts dir outfile
  chsafe=$(echo "$chan" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  [ -z "$chsafe" ] && chsafe="Channel"
  if [ -n "$show" ]; then
    showsafe=$(echo "$show" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  fi

  day=$(date -d "@$start_ts" +"%Y-%m-%d")
  ts=$(date -d "@$start_ts" +"%Y-%m-%d_%H-%M-%S")
  dir="$RECDIR/$chsafe/$day"
  mkdir -p "$dir"

  if [ -n "$showsafe" ]; then
    outfile="$dir/${chsafe}_${showsafe}_$ts.ts"
  else
    outfile="$dir/${chsafe}_$ts.ts"
  fi

  nohup bash -c "
    sleep $delay;
    ffmpeg -nostdin -y -i \"$url\" -t $duration -c copy \"$outfile\" >/dev/null 2>&1
  " >/dev/null 2>&1 &

  echo ">>> üìÖ Scheduled recording for $chan"
  echo "    Block: $label ‚Äì $show"
  echo "    File:  $outfile"
}

#########################################
### PLAY CHANNEL WITH SURFING (TVpass)
#########################################
play_channel() {
  local CUR="$1"
  local TABLE="$2"
  local LAST
  LAST=$(awk -F'\t' 'END{print $1}' "$TABLE")

  while true; do
    local NAME URL
    NAME=$(awk -F'\t' -v i="$CUR" '$1==i{print $2}' "$TABLE")
    URL=$(awk -F'\t' -v i="$CUR" '$1==i{print $3}' "$TABLE")

    clear
    echo -e "\e[96m‚ñ∂ CHANNEL $CUR: $NAME\e[0m"
    echo
    epg_now_next_block "$CUR"
    echo

    if recording_active; then
      echo -e "   \e[91m‚óè RECORDING ACTIVE (1 / r to stop)\e[0m"
      echo
    fi

    echo "   Ctrl+Up / Ctrl+Down ‚Üí Surf channels üîÄ"
    echo "   1 or r              ‚Üí Toggle recording (live) üî¥"
    echo "   q / ESC             ‚Üí Back to list ‚Ü©"
    echo

    mpv --fullscreen --input-conf="$INPUT_CONF" --quiet --msg-level=all=no "$URL"
    local code=$?

    case "$code" in
      3) CUR=$((CUR+1)); [ "$CUR" -gt "$LAST" ] && CUR=1 ;;
      4) CUR=$((CUR-1)); [ "$CUR" -lt 1 ] && CUR="$LAST" ;;
      5) toggle_recording "$URL" "$NAME" "$CUR" ;;
      *) break ;;
    esac
  done
}

#########################################
### FULL DAILY GUIDE FOR ONE CHANNEL (TVpass)
#########################################
channel_full_guide() {
  local NUM="$1"
  local TABLE="$2"

  local NAME URL
  NAME=$(awk -F'\t' -v i="$NUM" '$1==i{print $2}' "$TABLE")
  URL=$(awk -F'\t' -v i="$NUM" '$1==i{print $3}' "$TABLE")

  if [ -z "$NAME" ] || [ -z "$URL" ]; then
    echo "No such channel: $NUM"
    read -rp "Press ENTER to return..." _
    return
  fi

  local MAP
  MAP=$(mktemp)

  clear
  echo -e "\e[93m====== üìÖ DAILY GUIDE: $NUM ‚Äì $NAME (today, local time) ======\e[0m"
  echo

  python3 - "$EPG" "$NAME" "$MAP" << 'PY'
import sys, re
from datetime import datetime, timedelta
import xml.etree.ElementTree as ET

epg_path, playlist_name, map_path = sys.argv[1:]

tree = ET.parse(epg_path)
root = tree.getroot()

def canon_name(s: str) -> str:
    s = s or ""
    s = re.sub(r"\[[^\]]*\]", " ", s)
    s = re.sub(r"\([^)]*\)", " ", s)
    s = re.sub(r"[-‚Äì_|]", " ", s)
    for token in ["HD", "East", "West", "US", "USA", "Feed",
                  "TV", "Channel", "Network", "Latino"]:
        s = re.sub(r"\b" + re.escape(token) + r"\b", " ", s, flags=re.I)
    s = re.sub(r"\s+", " ", s).strip().lower()
    return s

def find_channel_id(name):
    name = (name or "").strip()
    if not name:
        return None
    chans = []
    for ch in root.findall("channel"):
        cid = ch.get("id","")
        names = [dn.text.strip() for dn in ch.findall("display-name") if dn.text]
        chans.append((cid,names))
    for cid,names in chans:
        for dn in names:
            if dn == name:
                return cid
    short = canon_name(name)
    for cid,names in chans:
        joined = " ".join(n for n in names if n)
        if short and short in canon_name(joined):
            return cid
    return None

def parse_dt(s):
    if not s: return None
    for fmt in ("%Y%m%d%H%M%S %z","%Y%m%d%H%M%S%z"):
        try:
            return datetime.strptime(s,fmt).astimezone()
        except Exception:
            continue
    return None

cid = find_channel_id(playlist_name)
if not cid:
    sys.exit(0)

progs = [p for p in root.findall("programme") if p.get("channel")==cid]

now = datetime.now().astimezone()
start_day = now.replace(hour=0, minute=0, second=0, microsecond=0)
end_day = start_day + timedelta(days=1)

rows = []
for p in progs:
    st = parse_dt(p.get("start"))
    en = parse_dt(p.get("stop"))
    if not st or not en:
        continue
    if en <= start_day or st >= end_day:
        continue
    t_el = p.find("title")
    title = t_el.text.strip() if (t_el is not None and t_el.text) else ""
    if not title:
        continue
    st_clip = max(st, start_day)
    en_clip = min(en, end_day)
    rows.append((st_clip,en_clip,title))

rows.sort(key=lambda r:r[0])

def human_label(dt_start, dt_end):
    return f"{dt_start.strftime('%-I:%M %p')}-{dt_end.strftime('%-I:%M %p')}"

with open(map_path,"w",encoding="utf-8") as mf:
    for st,en,title in rows:
        key = (st.strftime("%-I:%M%p")+ "-" + en.strftime("%-I:%M%p")).lower().replace(" ", "")
        label = human_label(st,en)
        mf.write(f"{key}\t{int(st.timestamp())}\t{int(en.timestamp())}\t{label}\t{title}\n")

for st,en,title in rows:
    print(f"  {human_label(st,en)}  {title}")
PY

  echo
  echo "Type:  record 6:30pm-7:00pm   to schedule that block üéØ"
  echo "       ENTER to go back to the channel list."
  echo

  while true; do
    local CMD
    read -rp "daily-guide> " CMD
    [ -z "$CMD" ] && break

    case "$CMD" in
      [Rr]ecord\ *)
        local ARG KEY
        ARG=${CMD#*[Rr]ecord }
        KEY=$(echo "$ARG" | tr -d ' ' | tr 'A-Z' 'a-z')
        if [ -z "$KEY" ]; then
          echo "Need a time range like: record 6:30pm-7:00pm"
          continue
        fi
        local INFO
        INFO=$(awk -F'\t' -v k="$KEY" '$1==k{print;exit}' "$MAP")
        if [ -z "$INFO" ]; then
          echo "No matching time block. Use exactly what you see."
          continue
        fi
        local ST_TS EN_TS LABEL TITLE
        IFS=$'\t' read -r _ ST_TS EN_TS LABEL TITLE <<< "$INFO"
        schedule_record_block "$URL" "$NAME" "$TITLE" "$ST_TS" "$EN_TS" "$LABEL"
        ;;
      *)
        echo "Unknown command. Use: record 6:30pm-7:00pm  or ENTER to leave."
        ;;
    esac
  done

  rm -f "$MAP"
}

#########################################
### GUIDE MODE ("G") ‚Äî TVpass
#########################################
guide_mode() {
  clear
  echo -e "\e[93m==================== üóìÔ∏è QUICK GUIDE ====================\e[0m"
  echo " Shows the next few blocks for each channel (local time)."
  echo " Enter a channel number to tune, or just ENTER to return."
  echo

  if [ -f "$GUIDE_CACHE" ]; then
    cat "$GUIDE_CACHE"
  else
    echo "Guide cache not built yet."
  fi

  local choice
  read -rp "Channel #: " choice
  if [ -n "$choice" ] && printf '%s\n' "$choice" | grep -Eq '^[0-9]+$'; then
    play_channel "$choice" "$TABLE"
  fi
}

#########################################
### HELP SCREEN
#########################################
help_screen() {
  clear
  echo -e "\e[96m============== üì∫ TV HELP ==============\e[0m"
  echo
  echo " Main screen (TVpass curated list):"
  echo "   ‚Ä¢ N               ‚Üí tune channel N"
  echo "   ‚Ä¢ G               ‚Üí quick guide (what's on each channel)"
  echo "   ‚Ä¢ G N             ‚Üí full 24h guide for channel N (today)"
  echo "   ‚Ä¢ more            ‚Üí open 10k+ global channels (world list) üåç"
  echo "   ‚Ä¢ h               ‚Üí this help screen"
  echo "   ‚Ä¢ recordings      ‚Üí open DVR recordings folder"
  echo "   ‚Ä¢ ENTER on blank  ‚Üí exit TV"
  echo
  echo " While watching any channel:"
  echo "   ‚Ä¢ Ctrl+Up / Ctrl+Down ‚Üí surf channels üîÄ"
  echo "   ‚Ä¢ 1 or r              ‚Üí toggle live recording üî¥"
  echo "   ‚Ä¢ q / ESC             ‚Üí back to channel list ‚Ü©"
  echo
  echo " Global/\"more\" side:"
  echo "   ‚Ä¢ Same surfing + recording keys"
  echo "   ‚Ä¢ Real schedule info only exists for the curated TVpass list."
  echo "     The huge global lists normally have no program guide at all."
  echo "     This script tries to reuse TVpass guide data where names match,"
  echo "     but most global channels will only show their names."
  echo
  echo " Recordings folder layout:"
  echo "   $RECDIR/<Channel>/<YYYY-MM-DD>/<Channel[_Show]_YYYY-MM-DD_HH-MM-SS>.ts"
  echo
  read -rp "Press ENTER to return..." _
}

#########################################
### OPEN RECORDINGS FOLDER
#########################################
open_recordings() {
  echo ">>> üìÇ Opening recordings folder: $RECDIR"
  if command -v thunar >/dev/null 2>&1; then
    thunar "$RECDIR" >/dev/null 2>&1 &
  elif command -v xdg-open >/dev/null 2>&1; then
    xdg-open "$RECDIR" >/dev/null 2>&1 &
  else
    echo "Open this path manually:"
    echo "  $RECDIR"
  fi
  read -rp "Press ENTER to return to channel list..." _
}

#########################################
### PRINT CHANNEL LIST WITH CURRENT SHOW (TVpass)
#########################################
print_channel_list() {
  local TABLE="$1"

  if [ -f "$NOW_CACHE" ]; then
    awk -F'\t' '
      FNR==NR {
        now[$1]=$3    # channel number ‚Üí now-title
        next
      }
      {
        num=$1; name=$2
        if (num == "") next
        if (num in now)
          printf "%-4s %s  \033[92m%.40s\033[0m\n", num, name, now[num]
        else
          printf "%-4s %s\n", num, name
      }
    ' "$NOW_CACHE" "$TABLE"
  else
    awk -F'\t' '
      {
        num=$1; name=$2
        if (num == "") next
        printf "%-4s %s\n", num, name
      }
    ' "$TABLE"
  fi
}

#########################################
### IPTV-ORG (GLOBAL / "more")
#########################################
iptv_ensure_playlist() {
  local file="$1"
  local url="$2"
  local label="$3"

  if [ -f "$file" ] && [ -s "$file" ]; then
    return 0
  fi

  echo ">>> üì° Downloading $label playlist..."
  if ! curl -sS -L "$url" -o "$file"; then
    echo "‚ùå Failed to download $label playlist."
    return 1
  fi
}

iptv_build_tmp_from_playlist() {
  local src="$1"
  local tmp="$2"

  awk -v OFS='\t' '
    BEGIN { name="" }
    /^#EXTINF/{
      name = $0
      sub(/.*,/, "", name)
      next
    }
    /^https?:\/\//{
      if (name == "") name = "Unknown"
      print name, $0
      name = ""
    }
  ' "$src" > "$tmp"
}

iptv_play_channel() {
  local CUR="$1"
  local TABLE="$2"
  local LAST
  LAST=$(awk 'END{print NR}' "$TABLE")

  while true; do
    local NAME URL
    NAME=$(awk -F'\t' -v i="$CUR" 'NR==i{print $1}' "$TABLE")
    URL=$(awk -F'\t' -v i="$CUR" 'NR==i{print $2}' "$TABLE")

    clear
    echo -e "\e[96m‚ñ∂ GLOBAL CHANNEL $CUR: $NAME\e[0m"
    echo "   (No native program guide for these global lists ‚Äì channel only) üåç"
    echo
    if recording_active; then
      echo -e "   \e[91m‚óè RECORDING ACTIVE (1 / r to stop)\e[0m"
      echo
    fi
    echo "   Ctrl+Up / Ctrl+Down ‚Üí Surf channels üîÄ"
    echo "   1 or r              ‚Üí Toggle recording üî¥"
    echo "   q / ESC             ‚Üí Back to list ‚Ü©"
    echo

    mpv --fullscreen --input-conf="$INPUT_CONF" --quiet --msg-level=all=no "$URL"
    local code=$?

    case "$code" in
      3) CUR=$((CUR+1)); [ "$CUR" -gt "$LAST" ] && CUR=1 ;;
      4) CUR=$((CUR-1)); [ "$CUR" -lt 1 ] && CUR="$LAST" ;;
      5) toggle_recording "$URL" "$NAME" "" ;;
      *) break ;;
    esac
  done
}

iptv_menu_from_tmp() {
  local tmp="$1"
  local label="$2"

  if [ ! -s "$tmp" ]; then
    echo "‚ùå No channels found in $label."
    read -rp "Press ENTER to return..." _
    return
  fi

  # Pre-render pretty list once so drawing is instant
  local PRETTY
  PRETTY="$(mktemp)"

  if [ -f "$NAME_NOW_CACHE" ]; then
    awk -F'\t' '
      function canon(s,    i) {
        gsub(/\[[^]]*\]/, " ", s)
        gsub(/\([^)]*\)/, " ", s)
        gsub(/[-‚Äì_|]/, " ", s)
        s=tolower(s)
        n=split("hd east west us usa feed tv channel network latino", a, " ")
        for (i=1; i<=n; i++) {
          gsub("(^|[[:space:]])" a[i] "([[:space:]]|$)", " ", s)
        }
        gsub(/[[:space:]]+/, " ", s)
        sub(/^[[:space:]]*/, "", s)
        sub(/[[:space:]]*$/, "", s)
        return s
      }
      FNR==NR {
        key = canon($1)
        if (key != "") now[key]=$2
        next
      }
      {
        name=$1
        key=canon(name)
        idx++
        if (key in now)
          printf "%4d. %s  \033[92m%.40s\033[0m\n", idx, name, now[key]
        else
          printf "%4d. %s\n", idx, name
      }
    ' "$NAME_NOW_CACHE" "$tmp" > "$PRETTY"
  else
    awk -F'\t' '
      {
        name=$1
        idx++
        printf "%4d. %s\n", idx, name
      }
    ' "$tmp" > "$PRETTY"
  fi

  local TOTAL
  TOTAL=$(wc -l < "$PRETTY")
  if [ "$TOTAL" -le 0 ]; then
    echo "‚ùå No displayable channels in GLOBAL / $label."
    rm -f "$PRETTY"
    read -rp "Press ENTER to return..." _
    return
  fi

  local PAGE_SIZE=40
  if [ "$PAGE_SIZE" -gt "$TOTAL" ]; then
    PAGE_SIZE="$TOTAL"
  fi
  local PAGE=1
  local MAX_PAGE=$(( (TOTAL + PAGE_SIZE - 1) / PAGE_SIZE ))

  while true; do
    local START END
    START=$(( (PAGE - 1) * PAGE_SIZE + 1 ))
    END=$(( START + PAGE_SIZE - 1 ))
    if [ "$END" -gt "$TOTAL" ]; then
      END="$TOTAL"
    fi

    clear
    echo -e "\e[96m==================== üåç WORLD CHANNELS (${label}) ====================\e[0m"
    echo " Page $PAGE / $MAX_PAGE  |  Channels $START‚Äì$END of $TOTAL"
    echo " Type a number ‚Üí play (global index)."
    echo " n = next page, p = previous page, ENTER = back."
    echo "======================================================================"
    echo

    sed -n "${START},${END}p" "$PRETTY"

    echo
    read -rp "Channel # or n/p: " CH
    case "$CH" in
      "" )
        break
        ;;
      n|N )
        if [ "$PAGE" -lt "$MAX_PAGE" ]; then
          PAGE=$((PAGE + 1))
        fi
        ;;
      p|P )
        if [ "$PAGE" -gt 1 ]; then
          PAGE=$((PAGE - 1))
        fi
        ;;
      * )
        if printf '%s\n' "$CH" | grep -Eq '^[0-9]+$'; then
          if [ "$CH" -ge 1 ] && [ "$CH" -le "$TOTAL" ]; then
            iptv_play_channel "$CH" "$tmp"
          fi
        fi
        ;;
    esac
  done

  rm -f "$PRETTY"
}

iptv_main_us() {
  iptv_ensure_playlist "$MAIN_PLAYLIST" "$MAIN_URL" "main (US)" || return
  command -v mpv >/dev/null || { echo "‚ùå mpv not installed"; read -rp "Press ENTER..." _; return; }

  local TMP
  TMP="$(mktemp)"
  iptv_build_tmp_from_playlist "$MAIN_PLAYLIST" "$TMP"
  iptv_menu_from_tmp "$TMP" "GLOBAL MAIN (US)"
  rm -f "$TMP"
}

iptv_global_language() {
  command -v mpv >/dev/null || { echo "‚ùå mpv not installed"; read -rp "Press ENTER..." _; return; }

  while true; do
    clear
    echo -e "\e[96m================ üåç GLOBAL (by language) ================\e[0m"
    echo " 1) All languages (full global index)"
    echo " 2) English"
    echo " 3) Spanish"
    echo " 4) French"
    echo " 5) German"
    echo " 6) Italian"
    echo " 7) Portuguese"
    echo " 8) Russian"
    echo " 9) Arabic"
    echo "10) Chinese"
    echo "11) Japanese"
    echo "12) Korean"
    echo "13) Hindi"
    echo "14) Back"
    echo "========================================================="
    read -rp "Choice: " LCH

    local SRC_URL SRC_FILE LANG_LABEL

    case "$LCH" in
      1)  SRC_URL="$GLOBAL_INDEX_URL"; SRC_FILE="$GLOBAL_INDEX"; LANG_LABEL="All" ;;
      2)  SRC_URL="https://iptv-org.github.io/iptv/languages/eng.m3u"; SRC_FILE="$TV_DIR/global-eng.m3u"; LANG_LABEL="English" ;;
      3)  SRC_URL="https://iptv-org.github.io/iptv/languages/spa.m3u"; SRC_FILE="$TV_DIR/global-spa.m3u"; LANG_LABEL="Spanish" ;;
      4)  SRC_URL="https://iptv-org.github.io/iptv/languages/fra.m3u"; SRC_FILE="$TV_DIR/global-fra.m3u"; LANG_LABEL="French" ;;
      5)  SRC_URL="https://iptv-org.github.io/iptv/languages/deu.m3u"; SRC_FILE="$TV_DIR/global-deu.m3u"; LANG_LABEL="German" ;;
      6)  SRC_URL="https://iptv-org.github.io/iptv/languages/ita.m3u"; SRC_FILE="$TV_DIR/global-ita.m3u"; LANG_LABEL="Italian" ;;
      7)  SRC_URL="https://iptv-org.github.io/iptv/languages/por.m3u"; SRC_FILE="$TV_DIR/global-por.m3u"; LANG_LABEL="Portuguese" ;;
      8)  SRC_URL="https://iptv-org.github.io/iptv/languages/rus.m3u"; SRC_FILE="$TV_DIR/global-rus.m3u"; LANG_LABEL="Russian" ;;
      9)  SRC_URL="https://iptv-org.github.io/iptv/languages/ara.m3u"; SRC_FILE="$TV_DIR/global-ara.m3u"; LANG_LABEL="Arabic" ;;
      10) SRC_URL="https://iptv-org.github.io/iptv/languages/zho.m3u"; SRC_FILE="$TV_DIR/global-zho.m3u"; LANG_LABEL="Chinese" ;;
      11) SRC_URL="https://iptv-org.github.io/iptv/languages/jpn.m3u"; SRC_FILE="$TV_DIR/global-jpn.m3u"; LANG_LABEL="Japanese" ;;
      12) SRC_URL="https://iptv-org.github.io/iptv/languages/kor.m3u"; SRC_FILE="$TV_DIR/global-kor.m3u"; LANG_LABEL="Korean" ;;
      13) SRC_URL="https://iptv-org.github.io/iptv/languages/hin.m3u"; SRC_FILE="$TV_DIR/global-hin.m3u"; LANG_LABEL="Hindi" ;;
      14|"") return ;;
      *) echo "Invalid choice"; sleep 1; continue ;;
    esac

    echo ">>> üì° Loading ${LANG_LABEL} playlist..."
    if ! curl -sS -L "$SRC_URL" -o "$SRC_FILE"; then
      echo "‚ùå Failed to load ${LANG_LABEL} playlist."
      read -rp "Press ENTER to return..." _
      return
    fi

    local TMP
    TMP="$(mktemp)"
    iptv_build_tmp_from_playlist "$SRC_FILE" "$TMP"
    if [ ! -s "$TMP" ]; then
      echo "‚ùå No channels in ${LANG_LABEL} playlist."
      rm -f "$TMP"
      read -rp "Press ENTER to return..." _
      continue
    fi
    iptv_menu_from_tmp "$TMP" "GLOBAL / ${LANG_LABEL}"
    rm -f "$TMP"
  done
}

iptv_search() {
  iptv_ensure_playlist "$GLOBAL_INDEX" "$GLOBAL_INDEX_URL" "global index (10k+)" || return
  command -v mpv >/dev/null || { echo "‚ùå mpv not installed"; read -rp "Press ENTER..." _; return; }

  local TMP
  TMP="$(mktemp)"
  iptv_build_tmp_from_playlist "$GLOBAL_INDEX" "$TMP"

  clear
  echo -e "\e[96m================ üîç SEARCH (GLOBAL) üåç =================\e[0m"
  echo "Searches channel names in the big world list."
  echo "========================================================"
  read -rp "Search term: " Q
  if [ -z "$Q" ]; then
    rm -f "$TMP"
    return
  fi

  local S_TMP
  S_TMP="$(mktemp)"
  while IFS=$'\t' read -r name url; do
    if printf '%s\n' "$name" | grep -iF -- "$Q" >/dev/null 2>&1; then
      printf '%s\t%s\n' "$name" "$url" >> "$S_TMP"
    fi
  done < "$TMP"

  if [ ! -s "$S_TMP" ]; then
    echo "‚ùå No channels matched '$Q'."
    rm -f "$TMP" "$S_TMP"
    read -rp "Press ENTER to return..." _
    return
  fi

  iptv_menu_from_tmp "$S_TMP" "SEARCH: $Q"
  rm -f "$TMP" "$S_TMP"
}

iptv_top_menu() {
  while true; do
    clear
    echo -e "\e[96m==================== üåç TV (GLOBAL) ====================\e[0m"
    echo " 1) Main list (US / iptv-org)"
    echo " 2) Global (by language)"
    echo " 3) Search (global by name) üîç"
    echo " 4) Back to TVpass main"
    echo "======================================================="
    read -rp "Choice: " CH

    case "$CH" in
      1) iptv_main_us ;;
      2) iptv_global_language ;;
      3) iptv_search ;;
      ""|4) break ;;
      *) echo "Invalid"; sleep 1 ;;
    esac
  done
}

#########################################
### MAIN MENU (TVpass)
#########################################
ensure_deps
ensure_input_conf
tvpass_ensure_playlist
tvpass_ensure_guide
show_disclaimer

echo ">>> ‚öôÔ∏è  Building TVpass channel list and guide..."
TABLE=$(build_table)
build_guide_cache "$TABLE"

# Pre-warm big global lists so they don't yell later (quiet)
iptv_ensure_playlist "$MAIN_PLAYLIST" "$MAIN_URL" "main (US)"      >/dev/null 2>&1
iptv_ensure_playlist "$GLOBAL_INDEX" "$GLOBAL_INDEX_URL" "global"  >/dev/null 2>&1

echo ">>> ‚úÖ Guide ready. Launching TV..."
sleep 1

case "$1" in
  update) tvpass_update_all ;;
  guide|G|g) guide_mode ;;
  *)
    while true; do
      clear
      echo -e "\e[92m==================== üì∫ TV CHANNELS (TVpass) ====================\e[0m"
      echo " Enter number ‚Üí play | G = guide | G N = day guide for N | h = help"
      echo " 'recordings' ‚Üí open DVR folder | 'more' ‚Üí world channel list üåç"
      echo " ENTER on blank line exits TV"
      echo
      print_channel_list "$TABLE"
      echo
      read -rp "Channel #: " CH

      [ -z "$CH" ] && break

      if printf '%s\n' "$CH" | grep -Eq '^[Gg][[:space:]]*[0-9]+$'; then
        NUM=$(printf '%s\n' "$CH" | sed 's/^[Gg][[:space:]]*//')
        channel_full_guide "$NUM" "$TABLE"
        continue
      fi

      case "$CH" in
        [Gg])        guide_mode;      continue ;;
        [Hh])        help_screen;     continue ;;
        recordings)  open_recordings; continue ;;
        more|More|MORE)
          iptv_top_menu
          continue
          ;;
      esac

      if ! printf '%s\n' "$CH" | grep -Eq '^[0-9]+$'; then
        continue
      fi

      play_channel "$CH" "$TABLE"
    done

    rm -f "$TABLE"
    ;;
esac
EOF

chmod +x "$HOME/.local/bin/tv"
echo ">>> TV 3.70 installed. Run: tv"
