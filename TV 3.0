cat > "$HOME/.local/bin/tv" << 'EOF'
#!/usr/bin/env bash
# TV 3.20 Runtime
# - Quick guide (G): 4 upcoming blocks per channel (local time)
# - Full daily guide (G N): 24h guide for channel N with time blocks
# - Main screen shows current title under each channel (1 line)
# - Tuning + surfing show NOW / NEXT / AFTER / LATER (titles only)
# - Uses system local time as anchor
# - Ctrl+Alt+R recording toggle with messages (live recording)
# - 'record 6:30pm-7:00pm' from full guide schedules that block
# - Recordings saved under recordings/<Channel>/<YYYY-MM-DD>/<Channel[_Show]_YYYY-MM-DD_HH-MM-SS>.ts
# - Channels >=178 removed (sports block)
# - 'h' = help, 'recordings' opens DVR folder in file manager

PLAYLIST="$HOME/TV/playlist.m3u"
EPG="$HOME/TV/epg.xml"
TVPASS_PLS="https://tvpass.org/playlist/m3u"
TVPASS_EPG="https://tvpass.org/epg.xml"
INPUT_CONF="$HOME/TV/tv-input.conf"
RECDIR="$HOME/TV/recordings"
REC_PIDFILE="$HOME/TV/recording.pid"
GUIDE_CACHE="$HOME/TV/guide-cache.txt"
NOW_CACHE="$HOME/TV/now-cache.txt"
EPG4_CACHE="$HOME/TV/epg-four.txt"

mkdir -p "$RECDIR"

#####################################
### INPUT CONF FOR MPV SURF BINDINGS
### (always rewrite so bindings stay in sync)
#####################################
ensure_input_conf() {
  cat > "$INPUT_CONF" << 'EOT'
ctrl+UP no-osd quit 3
ctrl+DOWN no-osd quit 4
ctrl+alt+r no-osd quit 5
EOT
}

#########################################
### PLAYLIST + EPG ENSURE / UPDATE
#########################################
ensure_playlist() {
  if [ ! -f "$PLAYLIST" ] || [ ! -s "$PLAYLIST" ]; then
    echo ">>> Downloading playlist..."
    curl -L "$TVPASS_PLS" -o "$PLAYLIST"
  fi
}

ensure_epg() {
  if [ ! -f "$EPG" ] || [ ! -s "$EPG" ]; then
    echo ">>> Downloading EPG..."
    curl -L "$TVPASS_EPG" -o "$EPG"
  fi
}

update_all() {
  echo "Updating playlist + EPG..."
  curl -L "$TVPASS_PLS" -o "$PLAYLIST"
  curl -L "$TVPASS_EPG" -o "$EPG"
  echo "✔ Updated."
  exit 0
}

#########################################
### PARSE PLAYLIST INTO TEMP TABLE
### (Drop channels 178+)
#########################################
build_table() {
  local TMP
  TMP=$(mktemp)
  awk -v OFS='\t' '
    BEGIN{n=0; name=""}
    /^#EXTINF/{
      sub(/.*,/, "", $0); name=$0; next
    }
    /^http/{
      if (n >= 177) next;   # drop everything from 178 onward
      n++; print n, (name==""?"Unknown":name), $0; name=""
    }
  ' "$PLAYLIST" > "$TMP"
  echo "$TMP"
}

#########################################
### BUILD GUIDE / NOW / FOUR-CACHE VIA PYTHON
### Uses local time; picks first 4 programmes with stop > now
#########################################
build_guide_cache() {
  local TABLE="$1"
  : > "$GUIDE_CACHE"
  : > "$NOW_CACHE"
  : > "$EPG4_CACHE"

  python3 - "$EPG" "$TABLE" "$GUIDE_CACHE" "$NOW_CACHE" "$EPG4_CACHE" << 'PY'
import sys, re
from datetime import datetime
import xml.etree.ElementTree as ET

epg_path, table_path, guide_path, now_path, four_path = sys.argv[1:]

tree = ET.parse(epg_path)
root = tree.getroot()

channels = []
for ch in root.findall("channel"):
    cid = ch.get("id", "")
    names = [dn.text.strip() for dn in ch.findall("display-name") if dn.text]
    channels.append((cid, names))

def canon_name(s: str) -> str:
    s = s or ""
    for token in ["HD", "East", "West", "US", "Feed"]:
        s = re.sub(r"\b" + re.escape(token) + r"\b", "", s, flags=re.I)
    s = re.sub(r"\s+", " ", s).strip().lower()
    return s

def find_channel_id(playlist_name: str):
    name = (playlist_name or "").strip()
    if not name:
        return None
    # exact
    for cid, names in channels:
        for dn in names:
            if dn == name:
                return cid
    # fuzzy
    short = canon_name(name)
    if not short:
        return None
    for cid, names in channels:
        joined = " ".join(n for n in names if n).lower()
        if short and short in joined:
            return cid
    return None

progs_by_id = {}
for p in root.findall("programme"):
    cid = p.get("channel")
    if not cid:
        continue
    progs_by_id.setdefault(cid, []).append(p)

def parse_dt(s: str):
    if not s:
        return None
    for fmt in ("%Y%m%d%H%M%S %z", "%Y%m%d%H%M%S%z"):
        try:
            return datetime.strptime(s, fmt).astimezone()
        except Exception:
            continue
    return None

now = datetime.now().astimezone()

def blocks_from_now(cid: str):
    """Return up to 4 (start, stop, title) blocks from 'now' onward."""
    progs = progs_by_id.get(cid, [])
    if not progs:
        return []
    out = []
    for p in progs:
        start = parse_dt(p.get("start"))
        stop = parse_dt(p.get("stop"))
        if not stop or not start:
            continue
        if stop > now:
            t_el = p.find("title")
            title = t_el.text.strip() if (t_el is not None and t_el.text) else ""
            if title:
                out.append((start, stop, title))
        if len(out) >= 4:
            break
    return out

with open(table_path, "r", encoding="utf-8") as tf, \
     open(guide_path, "w", encoding="utf-8") as gf, \
     open(now_path, "w", encoding="utf-8") as nf, \
     open(four_path, "w", encoding="utf-8") as ff:

    for line in tf:
        parts = line.rstrip("\n").split("\t")
        if len(parts) < 3:
            continue
        num, name, url = parts[0], parts[1], parts[2]
        if not num:
            continue

        cid = find_channel_id(name)
        if not cid:
            continue

        blocks = blocks_from_now(cid)
        if not blocks:
            continue

        titles = [b[2] for b in blocks]

        # NOW cache for main list
        nf.write(f"{num}\t{name}\t{titles[0]}\n")

        # 4-pack titles (for info overlay while watching)
        four_titles = titles + [""] * (4 - len(titles))
        ff.write(f"{num}\t" + "\t".join(four_titles[:4]) + "\n")

        # Human guide: time block in local time + title
        gf.write(f"\x1b[96m{num}. {name}\x1b[0m\n")
        for start, stop, title in blocks:
            tstr = f"{start.strftime('%-I:%M %p')}-{stop.strftime('%-I:%M %p')}"
            gf.write(f"   {tstr}  {title}\n")
        gf.write("\n")
PY
}

#########################################
### LOOK UP NOW-TITLE BY CHANNEL NUMBER
#########################################
now_title_for_num() {
  local num="$1"
  [ -f "$NOW_CACHE" ] || return
  awk -F'\t' -v n="$num" '$1==n{print $3; exit}' "$NOW_CACHE" 2>/dev/null
}

#########################################
### SURF INFO BLOCK: NOW / NEXT / AFTER / LATER (titles)
#########################################
epg_now_next_block() {
  local num="$1"
  [ -f "$EPG4_CACHE" ] || return
  local line
  line=$(awk -F'\t' -v n="$num" '$1==n{print; exit}' "$EPG4_CACHE" 2>/dev/null)
  [ -z "$line" ] && return

  IFS=$'\t' read -r _ NOW NEXT AFTER LATER <<< "$line"

  if [ -n "$NOW" ]; then
    echo -e "   \e[91mNOW: $NOW\e[0m"
  fi
  [ -n "$NEXT" ]  && echo "   NEXT:  $NEXT"
  [ -n "$AFTER" ] && echo "   AFTER: $AFTER"
  [ -n "$LATER" ] && echo "   LATER: $LATER"
}

#########################################
### DVR — LIVE TOGGLE RECORDING (current show)
#########################################
recording_active() {
  [ -f "$REC_PIDFILE" ] || return 1
  local pid
  pid=$(cat "$REC_PIDFILE" 2>/dev/null || echo "")
  [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null
}

start_recording() {
  local url="$1"
  local chan="$2"
  local show="$3"

  local chsafe showsafe day ts dir outfile
  chsafe=$(echo "$chan" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  [ -z "$chsafe" ] && chsafe="Channel"
  if [ -n "$show" ]; then
    showsafe=$(echo "$show" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  fi

  day=$(date +"%Y-%m-%d")
  ts=$(date +"%Y-%m-%d_%H-%M-%S")
  dir="$RECDIR/$chsafe/$day"
  mkdir -p "$dir"

  if [ -n "$showsafe" ]; then
    outfile="$dir/${chsafe}_${showsafe}_$ts.ts"
  else
    outfile="$dir/${chsafe}_$ts.ts"
  fi

  echo ">>> Recording started → $outfile"
  ffmpeg -nostdin -y -i "$url" -c copy "$outfile" >/dev/null 2>&1 &
  echo $! > "$REC_PIDFILE"
}

stop_recording() {
  local pid
  pid=$(cat "$REC_PIDFILE" 2>/dev/null || echo "")
  if [ -n "$pid" ]; then
    kill "$pid" 2>/dev/null || true
    wait "$pid" 2>/dev/null || true
  fi
  rm -f "$REC_PIDFILE"
  echo ">>> Recording stopped."
}

toggle_recording() {
  local url="$1"
  local chan="$2"
  local num="$3"   # channel number (for current show lookup)

  if recording_active; then
    stop_recording
  else
    local show=""
    if [ -n "$num" ]; then
      show=$(now_title_for_num "$num")
    fi
    start_recording "$url" "$chan" "$show"
  fi
}

#########################################
### SCHEDULED RECORDING FOR A TIME BLOCK
#########################################
schedule_record_block() {
  local url="$1"
  local chan="$2"
  local show="$3"
  local start_ts="$4"
  local end_ts="$5"
  local label="$6"

  local now_ts duration delay
  now_ts=$(date +%s)
  duration=$((end_ts - start_ts))
  if [ "$duration" -le 0 ]; then
    echo "Block has zero or negative duration, not scheduling."
    return
  fi
  delay=$((start_ts - now_ts))
  if [ "$delay" -lt 0 ]; then
    # already started, record remaining
    delay=0
    duration=$((end_ts - now_ts))
    [ "$duration" -le 0 ] && { echo "Block already finished."; return; }
  fi

  local chsafe showsafe day ts dir outfile
  chsafe=$(echo "$chan" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  [ -z "$chsafe" ] && chsafe="Channel"
  if [ -n "$show" ]; then
    showsafe=$(echo "$show" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  fi

  day=$(date -d "@$start_ts" +"%Y-%m-%d")
  ts=$(date -d "@$start_ts" +"%Y-%m-%d_%H-%M-%S")
  dir="$RECDIR/$chsafe/$day"
  mkdir -p "$dir"

  if [ -n "$showsafe" ]; then
    outfile="$dir/${chsafe}_${showsafe}_$ts.ts"
  else
    outfile="$dir/${chsafe}_$ts.ts"
  fi

  nohup bash -c "
    sleep $delay;
    ffmpeg -nostdin -y -i \"$url\" -t $duration -c copy \"$outfile\" >/dev/null 2>&1
  " >/dev/null 2>&1 &

  echo ">>> Scheduled recording for $chan"
  echo "    Block: $label – $show"
  echo "    File:  $outfile"
}

#########################################
### PLAY CHANNEL WITH SURFING
#########################################
play_channel() {
  local CUR="$1"
  local TABLE="$2"
  local LAST
  LAST=$(awk -F'\t' 'END{print $1}' "$TABLE")

  while true; do
    local NAME URL
    NAME=$(awk -F'\t' -v i="$CUR" '$1==i{print $2}' "$TABLE")
    URL=$(awk -F'\t' -v i="$CUR" '$1==i{print $3}' "$TABLE")

    clear
    echo -e "\e[96m▶ CHANNEL $CUR: $NAME\e[0m"
    echo
    epg_now_next_block "$CUR"
    echo

    if recording_active; then
      echo -e "   \e[91m● RECORDING ACTIVE (Ctrl+Alt+R to stop)\e[0m"
      echo
    fi

    echo "   Ctrl+Up / Ctrl+Down → Surf channels"
    echo "   Ctrl+Alt+R          → Toggle recording (live)"
    echo "   q / ESC             → Exit to channel list"
    echo

    mpv --fullscreen --input-conf="$INPUT_CONF" "$URL"
    local code=$?

    case "$code" in
      3)
        CUR=$((CUR+1))
        [ "$CUR" -gt "$LAST" ] && CUR=1
        ;;
      4)
        CUR=$((CUR-1))
        [ "$CUR" -lt 1 ] && CUR="$LAST"
        ;;
      5)
        toggle_recording "$URL" "$NAME" "$CUR"
        ;;
      *)
        break
        ;;
    esac
  done
}

#########################################
### FULL DAILY GUIDE FOR ONE CHANNEL
### G N from main menu, then 'record 6:30pm-7:00pm'
#########################################
channel_full_guide() {
  local NUM="$1"
  local TABLE="$2"

  local NAME URL
  NAME=$(awk -F'\t' -v i="$NUM" '$1==i{print $2}' "$TABLE")
  URL=$(awk -F'\t' -v i="$NUM" '$1==i{print $3}' "$TABLE")

  if [ -z "$NAME" ] || [ -z "$URL" ]; then
    echo "No such channel: $NUM"
    read -rp "Press ENTER to return..." _
    return
  fi

  local MAP
  MAP=$(mktemp)

  clear
  echo -e "\e[93m====== DAILY GUIDE: $NUM – $NAME (today, local time) ======\e[0m"
  echo

  python3 - "$EPG" "$NAME" "$MAP" << 'PY'
import sys, re
from datetime import datetime, timedelta
import xml.etree.ElementTree as ET

epg_path, playlist_name, map_path = sys.argv[1:]

tree = ET.parse(epg_path)
root = tree.getroot()

def canon_name(s: str) -> str:
    s = s or ""
    for token in ["HD", "East", "West", "US", "Feed"]:
        s = re.sub(r"\b" + re.escape(token) + r"\b", "", s, flags=re.I)
    s = re.sub(r"\s+", " ", s).strip().lower()
    return s

def find_channel_id(name):
    name = (name or "").strip()
    if not name:
        return None
    chans = []
    for ch in root.findall("channel"):
        cid = ch.get("id","")
        names = [dn.text.strip() for dn in ch.findall("display-name") if dn.text]
        chans.append((cid,names))
    for cid,names in chans:
        for dn in names:
            if dn == name:
                return cid
    short = canon_name(name)
    for cid,names in chans:
        joined = " ".join(n for n in names if n).lower()
        if short and short in joined:
            return cid
    return None

def parse_dt(s):
    if not s: return None
    for fmt in ("%Y%m%d%H%M%S %z","%Y%m%d%H%M%S%z"):
        try:
            return datetime.strptime(s,fmt).astimezone()
        except Exception:
            continue
    return None

cid = find_channel_id(playlist_name)
if not cid:
    sys.exit(0)

progs = [p for p in root.findall("programme") if p.get("channel")==cid]

now = datetime.now().astimezone()
start_day = now.replace(hour=0, minute=0, second=0, microsecond=0)
end_day = start_day + timedelta(days=1)

rows = []
for p in progs:
    st = parse_dt(p.get("start"))
    en = parse_dt(p.get("stop"))
    if not st or not en:
        continue
    if en <= start_day or st >= end_day:
        continue
    t_el = p.find("title")
    title = t_el.text.strip() if (t_el is not None and t_el.text) else ""
    if not title:
        continue
    st_clip = max(st, start_day)
    en_clip = min(en, end_day)
    rows.append((st_clip,en_clip,title))

rows.sort(key=lambda r:r[0])

def key_label(dt_start, dt_end):
    # key: e.g. "6:30pm-7:00pm" (no spaces, lowercase)
    l1 = dt_start.strftime("%-I:%M%p").lower().replace(" ", "")
    l2 = dt_end.strftime("%-I:%M%p").lower().replace(" ", "")
    return f"{l1}-{l2}"

def human_label(dt_start, dt_end):
    return f"{dt_start.strftime('%-I:%M %p')}-{dt_end.strftime('%-I:%M %p')}"

with open(map_path,"w",encoding="utf-8") as mf:
    for st,en,title in rows:
        key = key_label(st,en)
        label = human_label(st,en)
        mf.write(f"{key}\t{int(st.timestamp())}\t{int(en.timestamp())}\t{label}\t{title}\n")

for st,en,title in rows:
    print(f"  {human_label(st,en)}  {title}")
PY

  echo
  echo "Type:  record 6:30pm-7:00pm   to schedule that block"
  echo "       ENTER to go back to the channel list."
  echo

  while true; do
    local CMD
    read -rp "daily-guide> " CMD
    [ -z "$CMD" ] && break

    case "$CMD" in
      [Rr]ecord\ *)
        local ARG KEY
        ARG=${CMD#*[Rr]ecord }
        KEY=$(echo "$ARG" | tr -d ' ' | tr 'A-Z' 'a-z')
        if [ -z "$KEY" ]; then
          echo "Need a time range like: record 6:30pm-7:00pm"
          continue
        fi
        local INFO
        INFO=$(awk -F'\t' -v k="$KEY" '$1==k{print;exit}' "$MAP")
        if [ -z "$INFO" ]; then
          echo "No matching time block. Use exactly what you see, e.g. 6:30pm-7:00pm"
          continue
        fi
        local ST_TS EN_TS LABEL TITLE
        IFS=$'\t' read -r _ ST_TS EN_TS LABEL TITLE <<< "$INFO"
        schedule_record_block "$URL" "$NAME" "$TITLE" "$ST_TS" "$EN_TS" "$LABEL"
        ;;
      *)
        echo "Unknown command. Use: record 6:30pm-7:00pm  or ENTER to leave."
        ;;
    esac
  done

  rm -f "$MAP"
}

#########################################
### GUIDE MODE ("G") — USE PREBUILT CACHE
#########################################
guide_mode() {
  clear
  echo -e "\e[93m==================== TV GUIDE ====================\e[0m"
  echo " Next 4 upcoming blocks per channel (local time)."
  echo " Enter a channel number to tune, or just ENTER to return."
  echo

  if [ -f "$GUIDE_CACHE" ]; then
    cat "$GUIDE_CACHE"
  else
    echo "Guide cache not built yet."
  fi

  local choice
  read -rp "Channel #: " choice
  if [ -n "$choice" ] && printf '%s\n' "$choice" | grep -Eq '^[0-9]+$'; then
    play_channel "$choice" "$TABLE"
  fi
}

#########################################
### HELP SCREEN
#########################################
help_screen() {
  clear
  echo -e "\e[96m============== TV HELP ==============\e[0m"
  echo
  echo " Main screen:"
  echo "   • N               → tune channel N"
  echo "   • G               → quick guide (4 upcoming blocks/channel)"
  echo "   • G N             → full 24h guide for channel N (today)"
  echo "   • h               → this help screen"
  echo "   • recordings      → open DVR recordings folder"
  echo "   • ENTER on blank  → exit TV"
  echo
  echo " While watching:"
  echo "   • Ctrl+Up / Ctrl+Down → surf channels"
  echo "   • Ctrl+Alt+R          → toggle live recording for current show"
  echo "   • q / ESC             → back to channel list"
  echo
  echo " Full daily guide (G N view):"
  echo "   • Shows blocks as: 6:30 PM-7:00 PM  South Park"
  echo "   • Type:  record 6:30pm-7:00pm  to schedule that block"
  echo
  echo " Recordings layout:"
  echo "   $RECDIR/<Channel>/<YYYY-MM-DD>/<Channel[_Show]_YYYY-MM-DD_HH-MM-SS>.ts"
  echo
  read -rp "Press ENTER to return to channel list..." _
}

#########################################
### OPEN RECORDINGS FOLDER
#########################################
open_recordings() {
  echo ">>> Opening recordings folder: $RECDIR"
  if command -v xdg-open >/dev/null 2>&1; then
    xdg-open "$RECDIR" >/dev/null 2>&1 &
  else
    echo "xdg-open not found. Open this path manually:"
    echo "  $RECDIR"
  fi
  read -rp "Press ENTER to return to channel list..." _
}

#########################################
### PRINT CHANNEL LIST WITH CURRENT SHOW
#########################################
print_channel_list() {
  local TABLE="$1"
  while IFS=$'\t' read -r num name url; do
    [ -z "$num" ] && continue
    local nowt
    nowt=$(now_title_for_num "$num")
    if [ -n "$nowt" ]; then
      printf "%-4s %s  \e[92m%s\e[0m\n" "$num" "$name" "${nowt:0:40}"
    else
      printf "%-4s %s\n" "$num" "$name"
    fi
  done < "$TABLE"
}

#########################################
### MAIN MENU
#########################################
ensure_input_conf
ensure_playlist
ensure_epg

echo ">>> Building channel list and TV guide..."
TABLE=$(build_table)
build_guide_cache "$TABLE"
echo ">>> Guide ready. Launching TV..."
sleep 1

case "$1" in
  update) update_all ;;
  guide|G|g) guide_mode ;;
  *)
    while true; do
      clear
      echo -e "\e[92m==================== TV CHANNELS ====================\e[0m"
      echo " Enter number to play | G = guide | G N = daily guide for N | h = help"
      echo " Type 'recordings' to open DVR folder | ENTER to exit"
      echo
      print_channel_list "$TABLE"
      echo
      read -rp "Channel #: " CH

      [ -z "$CH" ] && break

      # G N → full daily guide for channel N
      if printf '%s\n' "$CH" | grep -Eq '^[Gg][[:space:]]*[0-9]+$'; then
        NUM=$(printf '%s\n' "$CH" | sed 's/^[Gg][[:space:]]*//')
        channel_full_guide "$NUM" "$TABLE"
        continue
      fi

      case "$CH" in
        [Gg])
          guide_mode
          continue
          ;;
        [Hh])
          help_screen
          continue
          ;;
        recordings)
          open_recordings
          continue
          ;;
      esac

      if ! printf '%s\n' "$CH" | grep -Eq '^[0-9]+$'; then
        continue
      fi

      play_channel "$CH" "$TABLE"
    done

    rm -f "$TABLE"
    ;;
esac
EOF

chmod +x "$HOME/.local/bin/tv"
echo ">>> TV 3.20 patched. Run: tv"
