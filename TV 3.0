bash << 'EOF'
set -euo pipefail

echo "============================================"
echo " TV 4.1 FULL UNINSTALL (w/ backup) + INSTALL TV 4.2"
echo "============================================"

TV_DIR="$HOME/TV"
RECDIR="$TV_DIR/recordings"
REC_PIDFILE="$TV_DIR/recording.pid"

# ----------------------------
# 0) Stop running TV/mpv/ffmpeg that belong to this setup
# ----------------------------
echo ">>> Stopping any active LIVE recording..."
if [ -f "$REC_PIDFILE" ]; then
  pid="$(cat "$REC_PIDFILE" 2>/dev/null || true)"
  if [ -n "${pid:-}" ] && kill -0 "$pid" 2>/dev/null; then
    kill "$pid" 2>/dev/null || true
    sleep 1
  fi
  rm -f "$REC_PIDFILE" || true
fi

echo ">>> Killing any leftover ffmpeg that is writing into ~/TV/recordings ..."
ps ax -o pid= -o args= | awk -v rec="$RECDIR" '
  index($0,"ffmpeg") && index($0,rec) {print $1}
' | while read -r p; do
  [ -n "$p" ] && kill "$p" 2>/dev/null || true
done

echo ">>> Killing any running 'tv' launcher (if any)..."
pkill -f "$HOME/.local/bin/tv" 2>/dev/null || true
sleep 0.5

# ----------------------------
# 1) Backup existing TV folder (so recordings/timers aren't lost)
# ----------------------------
TS="$(date +"%Y%m%d_%H%M%S")"
BACKUP_DIR="$HOME/TV.backup.$TS"

if [ -d "$TV_DIR" ]; then
  echo ">>> Backing up $TV_DIR -> $BACKUP_DIR"
  mv "$TV_DIR" "$BACKUP_DIR"
else
  echo ">>> No ~/TV folder found (ok)."
fi

# ----------------------------
# 2) Remove installed launcher(s)
# ----------------------------
echo ">>> Removing ~/.local/bin/tv"
rm -f "$HOME/.local/bin/tv" 2>/dev/null || true

echo ">>> Removing possible desktop launchers (if they exist)..."
rm -f "$HOME/.local/share/applications/tv.desktop" 2>/dev/null || true
rm -f "$HOME/Desktop/tv.desktop" 2>/dev/null || true

# ----------------------------
# 3) Purge main apt deps that this TV stack commonly installed
#    (Safe list: avoids ripping out curl/python3)
# ----------------------------
if command -v apt >/dev/null 2>&1; then
  echo ">>> Purging apt packages (mpv, fzf, ffmpeg, thunar) ..."
  sudo apt remove --purge -y mpv fzf ffmpeg thunar || true
  echo ">>> Autoremoving unused deps..."
  sudo apt autoremove -y || true
else
  echo "!!! apt not found. Skipping package purge."
fi

# ----------------------------
# 4) Reinstall deps
# ----------------------------
if command -v apt >/dev/null 2>&1; then
  echo ">>> Installing deps..."
  sudo apt update
  sudo apt install -y mpv curl thunar fzf ffmpeg python3
fi

# ----------------------------
# 5) Install TV 4.2 (fresh)
# ----------------------------
echo ">>> Installing TV 4.2 to ~/.local/bin/tv ..."
mkdir -p "$HOME/.local/bin"

cat > "$HOME/.local/bin/tv" << 'TVEOF'
#!/usr/bin/env bash
# TV 4.2 Runtime
# Upgrades over 4.1:
# - Clickable "â¬… Back" rows (no more trapped pages)
# - Local 12-hour clock shown in headers/prompts (screen-wide vibe)
# - Quick Guide fixed: one channel line + 4 blocks (no repeated channel numbers)
# - Quick Guide clickable to play
# - NEW: Channel Guide (24h) from Home
#   - Select time block -> Record Single (+30s auto) OR Record Series
# - NEW: 1080p HDTV section auto-built from Global index, categorized by keywords
# - Global search + timers screens get better emoji/boxing

set -euo pipefail

TV_DIR="$HOME/TV"

# TVpass
PLAYLIST="$TV_DIR/playlist.m3u"
EPG="$TV_DIR/epg.xml"
TVPASS_PLS="https://tvpass.org/playlist/m3u"
TVPASS_EPG="https://tvpass.org/epg.xml"

# Global (iptv-org)
MAIN_PLAYLIST="$TV_DIR/main.m3u"
GLOBAL_INDEX="$TV_DIR/global-index.m3u"
MAIN_URL="https://iptv-org.github.io/iptv/countries/us.m3u"
GLOBAL_INDEX_URL="https://iptv-org.github.io/iptv/index.m3u"

# Runtime
INPUT_CONF="$TV_DIR/tv-input.conf"
RECDIR="$TV_DIR/recordings"
REC_PIDFILE="$TV_DIR/recording.pid"
TIMERS_DB="$TV_DIR/timers.db"

# Caches
NOW_CACHE="$TV_DIR/now-cache.txt"           # num \t name \t now-title
EPG4_CACHE="$TV_DIR/epg-four.txt"           # num \t NOW \t NEXT \t AFTER \t LATER
GUIDE_LIST_CACHE="$TV_DIR/guide-list.txt"   # quick guide rows (one per channel)
GUIDE24_MAP="$TV_DIR/guide24-map.tsv"       # per-channel 24h map for recording
HD1080_DB="$TV_DIR/hd1080.tsv"              # name \t url \t cat

mkdir -p "$TV_DIR" "$RECDIR"

RECORD_CONFIRM=""
STORAGE_TIER="hdd"
MAX_BG_RECORDINGS=3
MAX_LIVE_RECORDINGS=1

clock12() { date '+%-I:%M %p'; }

#########################################
# STORAGE TIER (HDD vs SSD)
#########################################
detect_storage_tier() {
  local dev base rota
  dev=$(df --output=source "$TV_DIR" 2>/dev/null | tail -n1 || true)
  [ -z "${dev:-}" ] && { STORAGE_TIER="hdd"; MAX_BG_RECORDINGS=3; return; }
  base="${dev%%[0-9p]*}"
  rota=$(lsblk -ndo ROTA "$base" 2>/dev/null | head -n1 || true)
  case "${rota:-}" in
    0) STORAGE_TIER="ssd"; MAX_BG_RECORDINGS=6 ;;
    1) STORAGE_TIER="hdd"; MAX_BG_RECORDINGS=3 ;;
    *) STORAGE_TIER="hdd"; MAX_BG_RECORDINGS=3 ;;
  esac
}

active_bg_recordings() {
  local live
  live=""
  [ -f "$REC_PIDFILE" ] && live=$(cat "$REC_PIDFILE" 2>/dev/null || echo "")
  ps ax -o pid= -o args= 2>/dev/null | awk -v live="$live" -v rec="$RECDIR" '
    index($0,"ffmpeg") && index($0,rec) {
      if ($1 != live) count++
    }
    END{print count+0}'
}

prevent_sleep() {
  if command -v xset >/dev/null 2>&1; then
    xset s off -dpms >/dev/null 2>&1 || true
  fi
}

#########################################
# DEPS
#########################################
ensure_deps() {
  local need=0
  command -v mpv    >/dev/null 2>&1 || need=1
  command -v curl   >/dev/null 2>&1 || need=1
  command -v fzf    >/dev/null 2>&1 || need=1
  command -v ffmpeg >/dev/null 2>&1 || need=1
  command -v python3 >/dev/null 2>&1 || need=1

  if [ "$need" -eq 1 ] && command -v apt >/dev/null 2>&1; then
    sudo apt update
    sudo apt install -y mpv curl fzf ffmpeg python3 thunar
  fi
}

#########################################
# MPV INPUT CONF
#########################################
ensure_input_conf() {
  cat > "$INPUT_CONF" << 'EOT'
ctrl+UP no-osd quit 3
ctrl+DOWN no-osd quit 4
1 no-osd quit 5
r no-osd quit 5
EOT
}

#########################################
# TVPASS FETCH
#########################################
tvpass_ensure_playlist() {
  if [ ! -s "$PLAYLIST" ]; then
    echo ">>> Downloading TVpass playlist..."
    curl -sS -L "$TVPASS_PLS" -o "$PLAYLIST"
  fi
}
tvpass_ensure_guide() {
  if [ ! -s "$EPG" ]; then
    echo ">>> Downloading TVpass EPG..."
    curl -sS -L "$TVPASS_EPG" -o "$EPG"
  fi
}
tvpass_update_all() {
  echo "âŸ³ Updating TVpass playlist + guide..."
  curl -sS -L "$TVPASS_PLS" -o "$PLAYLIST"
  curl -sS -L "$TVPASS_EPG" -o "$EPG"
  echo "âœ” Done."
  exit 0
}

#########################################
# TABLE BUILDER (TVPASS)
#########################################
build_table() {
  local TMP
  TMP=$(mktemp)
  awk -v OFS='\t' '
    BEGIN{n=0; name=""}
    /^#EXTINF/{
      sub(/.*,/, "", $0); name=$0; next
    }
    /^http/{
      if (n >= 177) next
      n++; print n, (name==""?"Unknown":name), $0; name=""
    }
  ' "$PLAYLIST" > "$TMP"
  echo "$TMP"
}

#########################################
# EPG CACHES + QUICK GUIDE (ONE LINE / CHANNEL)
#########################################
build_epg_caches_and_quickguide() {
  local TABLE="$1"
  : > "$NOW_CACHE"
  : > "$EPG4_CACHE"
  : > "$GUIDE_LIST_CACHE"

  python3 - "$EPG" "$TABLE" "$NOW_CACHE" "$EPG4_CACHE" "$GUIDE_LIST_CACHE" << 'PY'
import sys, re
from datetime import datetime
import xml.etree.ElementTree as ET

epg_path, table_path, now_path, four_path, qg_path = sys.argv[1:]

tree = ET.parse(epg_path)
root = tree.getroot()

def canon_name(s: str) -> str:
    s = s or ""
    s = re.sub(r"\[[^\]]*\]", " ", s)
    s = re.sub(r"\([^)]*\)", " ", s)
    s = re.sub(r"[-â€“_|]", " ", s)
    for token in ["HD","East","West","US","USA","Feed","TV","Channel","Network","Latino"]:
        s = re.sub(r"\b"+re.escape(token)+r"\b"," ",s,flags=re.I)
    s = re.sub(r"\s+"," ",s).strip().lower()
    return s

channels = []
for ch in root.findall("channel"):
    cid = ch.get("id","")
    names = [dn.text.strip() for dn in ch.findall("display-name") if dn.text]
    channels.append((cid,names))

def find_channel_id(name):
    name = (name or "").strip()
    if not name:
        return None
    for cid,names in channels:
        for dn in names:
            if dn == name:
                return cid
    short = canon_name(name)
    if not short:
        return None
    for cid,names in channels:
        joined = " ".join(n for n in names if n)
        if short and short in canon_name(joined):
            return cid
    return None

progs_by_id = {}
for p in root.findall("programme"):
    cid = p.get("channel")
    if not cid: continue
    progs_by_id.setdefault(cid,[]).append(p)

def parse_dt(s):
    if not s: return None
    for fmt in ("%Y%m%d%H%M%S %z","%Y%m%d%H%M%S%z"):
        try:
            return datetime.strptime(s,fmt).astimezone()
        except Exception:
            continue
    return None

now = datetime.now().astimezone()

def next_blocks(cid, limit=4):
    progs = progs_by_id.get(cid,[])
    out = []
    for p in progs:
        st = parse_dt(p.get("start"))
        en = parse_dt(p.get("stop"))
        if not st or not en: continue
        if en <= now: continue
        t_el = p.find("title")
        title = (t_el.text.strip() if (t_el is not None and t_el.text) else "")
        if title:
            out.append((st,en,title))
        if len(out) >= limit:
            break
    return out

def human(st,en):
    return f"{st.strftime('%-I:%M %p')}-{en.strftime('%-I:%M %p')}"

with open(table_path,"r",encoding="utf-8") as tf, \
     open(now_path,"w",encoding="utf-8") as nf, \
     open(four_path,"w",encoding="utf-8") as ff, \
     open(qg_path,"w",encoding="utf-8") as qg:

    for line in tf:
        parts = line.rstrip("\n").split("\t")
        if len(parts) < 3: continue
        num,name,url = parts[0],parts[1],parts[2]
        cid = find_channel_id(name)
        if not cid: 
            continue
        blocks = next_blocks(cid, 4)
        if not blocks:
            continue

        titles = [b[2] for b in blocks]
        while len(titles) < 4:
            titles.append("")

        nf.write(f"{num}\t{name}\t{titles[0]}\n")
        ff.write(f"{num}\t{titles[0]}\t{titles[1]}\t{titles[2]}\t{titles[3]}\n")

        # Quick Guide row: ONE channel line + 4 blocks
        # Format: [ 17] ðŸ“º Name | 8:00 PM Show | 8:30 PM Show | ...
        segs = []
        for st,en,title in blocks[:4]:
            segs.append(f"{st.strftime('%-I:%M %p')} {title[:34]}")
        while len(segs) < 4:
            segs.append("")
        row = f"[{int(num):3d}] ðŸ“º {name[:32]:32s} | {segs[0]:40s} | {segs[1]:40s} | {segs[2]:40s} | {segs[3]:40s}"
        qg.write(row.rstrip()+"\n")
PY
}

now_title_for_num() {
  local num="$1"
  [ -f "$NOW_CACHE" ] || return
  awk -F'\t' -v n="$num" '$1==n{print $3;exit}' "$NOW_CACHE" 2>/dev/null
}

epg_now_next_block() {
  local num="$1"
  [ -f "$EPG4_CACHE" ] || return
  local line
  line=$(awk -F'\t' -v n="$num" '$1==n{print;exit}' "$EPG4_CACHE" 2>/dev/null)
  [ -z "$line" ] && return
  IFS=$'\t' read -r _ NOW NEXT AFTER LATER <<< "$line"
  [ -n "$NOW" ]  && echo -e "   \e[91mNOW:  $NOW\e[0m"
  [ -n "$NEXT" ] && echo    "   NEXT: $NEXT"
  [ -n "$AFTER" ]&& echo    "   AFTER: $AFTER"
  [ -n "$LATER" ]&& echo    "   LATER: $LATER"
}

#########################################
# DVR: LIVE
#########################################
recording_active() {
  [ -f "$REC_PIDFILE" ] || return 1
  local pid
  pid=$(cat "$REC_PIDFILE" 2>/dev/null || echo "")
  [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null
}

start_recording() {
  local url="$1" chan="$2" show="$3"
  local chsafe showsafe day ts dir outfile
  chsafe=$(echo "$chan" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  [ -z "$chsafe" ] && chsafe="Channel"
  showsafe=""
  [ -n "${show:-}" ] && showsafe=$(echo "$show" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  day=$(date +"%Y-%m-%d")
  ts=$(date +"%Y-%m-%d_%H-%M-%S")
  dir="$RECDIR/$chsafe/$day"
  mkdir -p "$dir"
  if [ -n "$showsafe" ]; then
    outfile="$dir/${chsafe}_${showsafe}_$ts.ts"
  else
    outfile="$dir/${chsafe}_$ts.ts"
  fi
  echo ">>> LIVE recording â†’ $outfile"
  (
    ffmpeg -nostdin -y -i "$url" -c copy "$outfile" >/dev/null 2>&1
    rm -f "$REC_PIDFILE"
  ) &
  echo $! > "$REC_PIDFILE"
}

stop_recording() {
  local pid
  pid=$(cat "$REC_PIDFILE" 2>/dev/null || echo "")
  if [ -n "$pid" ]; then
    kill "$pid" 2>/dev/null || true
    wait "$pid" 2>/dev/null || true
  fi
  rm -f "$REC_PIDFILE"
  echo ">>> LIVE recording stopped."
}

toggle_recording() {
  local url="$1" chan="$2" num="$3"
  if recording_active; then
    if [ "$RECORD_CONFIRM" != "yes" ]; then
      echo ">>> LIVE recording already running."
      echo ">>> Press 1 or r again to STOP it."
      RECORD_CONFIRM="yes"
      return
    fi
    stop_recording
    RECORD_CONFIRM=""
  else
    RECORD_CONFIRM=""
    local show=""
    [ -n "${num:-}" ] && show=$(now_title_for_num "$num" || true)
    start_recording "$url" "$chan" "$show"
  fi
}

#########################################
# SCHEDULED RECORDING (BLOCKS) +30s option
#########################################
schedule_record_block() {
  local url="$1" chan="$2" show="$3" start_ts="$4" end_ts="$5" label="$6" pad_end="${7:-0}"
  local now_ts duration delay
  now_ts=$(date +%s)
  end_ts=$((end_ts + pad_end))
  duration=$((end_ts - start_ts))
  [ "$duration" -le 0 ] && { echo "Block already done."; return; }
  delay=$((start_ts - now_ts))
  if [ "$delay" -lt 0 ]; then
    delay=0
    duration=$((end_ts - now_ts))
    [ "$duration" -le 0 ] && { echo "Block already finished."; return; }
  fi

  local chsafe showsafe day ts dir outfile
  chsafe=$(echo "$chan" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  [ -z "$chsafe" ] && chsafe="Channel"
  showsafe=""
  [ -n "${show:-}" ] && showsafe=$(echo "$show" | tr ' /' '__' | tr -cd 'A-Za-z0-9_.-')
  day=$(date -d "@$start_ts" +"%Y-%m-%d")
  ts=$(date -d "@$start_ts" +"%Y-%m-%d_%H-%M-%S")
  dir="$RECDIR/$chsafe/$day"
  mkdir -p "$dir"
  if [ -n "$showsafe" ]; then
    outfile="$dir/${chsafe}_${showsafe}_$ts.ts"
  else
    outfile="$dir/${chsafe}_$ts.ts"
  fi

  if [ -f "$outfile" ]; then
    echo ">>> Already have recording for $chan â€“ $show at $label, skipping."
    return
  fi

  local current
  current=$(active_bg_recordings)
  if [ "$current" -ge "$MAX_BG_RECORDINGS" ]; then
    echo ">>> âš  Background cap hit ($current/$MAX_BG_RECORDINGS). Not scheduling:"
    echo "    $chan â€“ $show ($label)"
    return
  fi

  nohup bash -c "
    sleep $delay
    ffmpeg -nostdin -y -i \"$url\" -t $duration -c copy \"$outfile\" >/dev/null 2>&1
  " >/dev/null 2>&1 &

  echo ">>> âœ… TIMER scheduled: $chan"
  echo "    ðŸ§± Block: $label â€“ $show"
  echo "    ðŸ“ File:  $outfile"
  if [ "$pad_end" -gt 0 ]; then
    echo "    â± End padding: +${pad_end}s"
  fi
}

#########################################
# SERIES TIMERS
#########################################
add_series_timer() {
  local num="$1" title="$2"
  [ -z "${num:-}" ] && return
  [ -z "${title:-}" ] && return
  mkdir -p "$TV_DIR"
  local norm
  norm=$(printf '%s\n' "$title" | sed 's/^ *//;s/ *$//')
  if [ -f "$TIMERS_DB" ] && awk -F'\t' -v n="$num" -v t="$(printf '%s\n' "$norm" | tr 'A-Z' 'a-z')" '
    {
      if (NF>=2 && $1==n && tolower($2)==t) { found=1 }
    }
    END{exit !found}
  ' "$TIMERS_DB"; then
    echo "Series timer already exists: $num â€“ $norm"
    return
  fi
  echo -e "${num}\t${norm}" >> "$TIMERS_DB"
  echo ">>> âœ… Added series timer: ch ${num} â€“ ${norm}"
}

timers_list() {
  clear
  echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
  echo "â•‘ â±  TV â–¸ Timers â–¸ List     $(clock12)     â•‘"
  echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo
  if [ ! -s "$TIMERS_DB" ]; then
    echo "No series timers."
    echo
    read -rp "ENTER..." _
    return
  fi
  nl -ba "$TIMERS_DB" | sed 's/\t/  â†’  /'
  echo
  read -rp "ENTER..." _
}

timers_scan() {
  clear
  echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
  echo "â•‘ ðŸ”  TV â–¸ Timers â–¸ Scan EPG  $(clock12)   â•‘"
  echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo
  tvpass_ensure_playlist
  tvpass_ensure_guide
  [ ! -s "$TIMERS_DB" ] && { echo "No timers to scan."; echo; read -rp "ENTER..." _; return; }

  local TABLE TMP
  TABLE=$(build_table)
  TMP=$(mktemp)

  python3 - "$EPG" "$TIMERS_DB" "$TABLE" > "$TMP" << 'PY'
import sys, re
from datetime import datetime, timedelta
import xml.etree.ElementTree as ET

epg_path, timers_path, table_path = sys.argv[1:]

tree = ET.parse(epg_path)
root = tree.getroot()

def canon_name(s: str) -> str:
    s = s or ""
    s = re.sub(r"\[[^\]]*\]", " ", s)
    s = re.sub(r"\([^)]*\)", " ", s)
    s = re.sub(r"[-â€“_|]", " ", s)
    for token in ["HD","East","West","US","USA","Feed","TV","Channel","Network","Latino"]:
        s = re.sub(r"\b"+re.escape(token)+r"\b"," ",s,flags=re.I)
    s = re.sub(r"\s+"," ",s).strip().lower()
    return s

channels = []
for ch in root.findall("channel"):
    cid = ch.get("id","")
    names = [dn.text.strip() for dn in ch.findall("display-name") if dn.text]
    channels.append((cid,names))

def find_channel_id(name):
    name=(name or "").strip()
    if not name: return None
    for cid,names in channels:
        for dn in names:
            if dn == name:
                return cid
    short=canon_name(name)
    if not short: return None
    for cid,names in channels:
        joined=" ".join(n for n in names if n)
        if short and short in canon_name(joined):
            return cid
    return None

progs_by_id = {}
for p in root.findall("programme"):
    cid = p.get("channel")
    if not cid: continue
    progs_by_id.setdefault(cid,[]).append(p)

def parse_dt(s):
    if not s: return None
    for fmt in ("%Y%m%d%H%M%S %z","%Y%m%d%H%M%S%z"):
        try:
            return datetime.strptime(s,fmt).astimezone()
        except Exception:
            continue
    return None

num_to_name={}
with open(table_path,"r",encoding="utf-8") as tf:
    for line in tf:
        parts=line.rstrip("\n").split("\t")
        if len(parts)<2: continue
        num_to_name[parts[0]]=parts[1]

now=datetime.now().astimezone()
horizon=now+timedelta(days=2)

def human(st,en):
    return f"{st.strftime('%-I:%M %p')}-{en.strftime('%-I:%M %p')}"

with open(timers_path,"r",encoding="utf-8") as tf:
    for line in tf:
        line=line.strip()
        if not line: continue
        parts=line.split("\t",1)
        if len(parts)<2: continue
        num,title=parts[0],parts[1].strip()
        chan_name=num_to_name.get(num)
        if not chan_name: continue
        cid=find_channel_id(chan_name)
        if not cid: continue
        wanted=title.lower()
        for p in progs_by_id.get(cid,[]):
            st=parse_dt(p.get("start")); en=parse_dt(p.get("stop"))
            if not st or not en: continue
            if en<=now or st>=horizon: continue
            t_el=p.find("title")
            ttxt=(t_el.text.strip() if (t_el is not None and t_el.text) else "")
            if not ttxt: continue
            if ttxt.strip().lower()!=wanted: continue
            print(f"{num}\t{int(st.timestamp())}\t{int(en.timestamp())}\t{ttxt}\t{human(st,en)}")
PY

  if [ ! -s "$TMP" ]; then
    echo "No upcoming episodes found."
    rm -f "$TMP" "$TABLE"
    echo
    read -rp "ENTER..." _
    return
  fi

  echo ">>> Scheduling episodes..."
  while IFS=$'\t' read -r NUM ST_TS EN_TS TITLE LABEL; do
    [ -z "${NUM:-}" ] && continue
    NAME=$(awk -F'\t' -v i="$NUM" '$1==i{print $2}' "$TABLE")
    URL=$(awk -F'\t' -v i="$NUM" '$1==i{print $3}' "$TABLE")
    [ -z "${URL:-}" ] && continue
    schedule_record_block "$URL" "$NAME" "$TITLE" "$ST_TS" "$EN_TS" "$LABEL"
  done < "$TMP"

  rm -f "$TMP" "$TABLE"
  echo
  echo "Done."
  read -rp "ENTER..." _
}

#########################################
# WATCHING (TVPASS)
#########################################
play_channel() {
  local CUR="$1" TABLE="$2"
  local LAST NAME URL
  LAST=$(awk -F'\t' 'END{print $1}' "$TABLE")

  while true; do
    NAME=$(awk -F'\t' -v i="$CUR" '$1==i{print $2}' "$TABLE")
    URL=$(awk -F'\t' -v i="$CUR" '$1==i{print $3}' "$TABLE")

    clear
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    printf "â•‘ TV â–¸ TVpass â–¸ Watching   %-10s â•‘\n" "$(clock12)"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "\e[96mâ–¶ Channel $CUR: $NAME\e[0m"
    echo
    epg_now_next_block "$CUR"
    echo
    recording_active && echo -e "   \e[91mâ— LIVE RECORDING (1/r to stop)\e[0m\n"

    # â€œClickable buttonsâ€ in TUI reality = obvious labeled controls:
    echo "   Ctrl+Up/Down â†’ surf | 1/r â†’ live rec | q/Esc â†’ back"
    echo "   â¬† Channel Up (Ctrl+Up)   â¬‡ Channel Down (Ctrl+Down)   âŒ Cancel Watch (q/Esc)"
    echo

    [ -z "${URL:-}" ] && { echo "!!! No URL for channel $CUR"; read -rp "ENTER..." _; break; }

    mpv --fullscreen --input-conf="$INPUT_CONF" "$URL"
    code=$?
    case "$code" in
      3) CUR=$((CUR+1)); [ "$CUR" -gt "$LAST" ] && CUR=1 ;;
      4) CUR=$((CUR-1)); [ "$CUR" -lt 1 ] && CUR="$LAST" ;;
      5) toggle_recording "$URL" "$NAME" "$CUR" ;;
      *) break ;;
    esac
  done
}

#########################################
# CLICKABLE TVPASS CHANNEL LIST (with Back row)
#########################################
print_tvpass_channel_rows() {
  local TABLE="$1"
  if [ -f "$NOW_CACHE" ]; then
    awk -F'\t' '
      FNR==NR { now[$1]=$3; next }
      {
        num=$1; name=$2
        if (num=="") next
        if (num in now)
          printf "[%3s] ðŸ“º %-32s  \033[92m%.46s\033[0m\n", num, name, now[num]
        else
          printf "[%3s] ðŸ“º %s\n", num, name
      }
    ' "$NOW_CACHE" "$TABLE"
  else
    awk -F'\t' '{ if($1!="") printf "[%3s] ðŸ“º %s\n", $1, $2 }' "$TABLE"
  fi
  printf "[---] â¬… Back\n"
}

choose_tvpass_channel() {
  local TABLE="$1"
  local choice
  choice=$(
    print_tvpass_channel_rows "$TABLE" |
    fzf --ansi \
        --prompt="TV â–¸ TVpass â–¸ Channels ($(clock12)) > " \
        --header="Mouse/arrows: move â€¢ ENTER: tune â€¢ ESC: back" \
        --height=100% --reverse --border
  ) || true
  [ -z "${choice:-}" ] && return 1
  if echo "$choice" | grep -q "â¬… Back"; then
    return 1
  fi
  echo "$choice" | sed 's/^\[\s*\([0-9]\+\)\].*/\1/' 2>/dev/null
}

#########################################
# 24H CHANNEL GUIDE (TVPASS) + RECORD CHOOSER
#########################################
build_channel_24h_map() {
  local chan_name="$1"
  : > "$GUIDE24_MAP"
  python3 - "$EPG" "$chan_name" "$GUIDE24_MAP" << 'PY'
import sys, re
from datetime import datetime, timedelta
import xml.etree.ElementTree as ET

epg_path, chan_name, out_path = sys.argv[1:]
tree=ET.parse(epg_path); root=tree.getroot()

def canon(s:str)->str:
    s=s or ""
    s=re.sub(r"\[[^\]]*\]"," ",s)
    s=re.sub(r"\([^)]*\)"," ",s)
    s=re.sub(r"[-â€“_|]"," ",s)
    s=re.sub(r"\s+"," ",s).strip().lower()
    return s

def parse_dt(s):
    if not s: return None
    for fmt in ("%Y%m%d%H%M%S %z","%Y%m%d%H%M%S%z"):
        try: return datetime.strptime(s,fmt).astimezone()
        except: pass
    return None

# find channel id
cid=None
for ch in root.findall("channel"):
    names=[dn.text.strip() for dn in ch.findall("display-name") if dn.text]
    if any(n==chan_name for n in names):
        cid=ch.get("id"); break
if not cid:
    # fuzzy
    want=canon(chan_name)
    for ch in root.findall("channel"):
        names=[dn.text.strip() for dn in ch.findall("display-name") if dn.text]
        joined=" ".join(names)
        if want and want in canon(joined):
            cid=ch.get("id"); break

if not cid:
    open(out_path,"w").close()
    sys.exit(0)

now=datetime.now().astimezone()
start=now.replace(hour=0,minute=0,second=0,microsecond=0)
end=start+timedelta(days=1)

rows=[]
for p in root.findall("programme"):
    if p.get("channel")!=cid: continue
    st=parse_dt(p.get("start")); en=parse_dt(p.get("stop"))
    if not st or not en: continue
    if en<=start or st>=end: continue
    t_el=p.find("title")
    title=(t_el.text.strip() if (t_el is not None and t_el.text) else "")
    if not title: continue
    stc=max(st,start); enc=min(en,end)
    rows.append((stc,enc,title))

rows.sort(key=lambda r:r[0])

def human(st,en):
    return f"{st.strftime('%-I:%M %p')}â€“{en.strftime('%-I:%M %p')}"

with open(out_path,"w",encoding="utf-8") as f:
    for st,en,title in rows:
        f.write(f"{int(st.timestamp())}\t{int(en.timestamp())}\t{human(st,en)}\t{title}\n")
PY
}

channel_guide_24h() {
  local NUM="$1" TABLE="$2"
  local NAME URL
  NAME=$(awk -F'\t' -v i="$NUM" '$1==i{print $2}' "$TABLE")
  URL=$(awk -F'\t' -v i="$NUM" '$1==i{print $3}' "$TABLE")
  [ -z "${NAME:-}" ] && return

  build_channel_24h_map "$NAME"
  if [ ! -s "$GUIDE24_MAP" ]; then
    clear
    echo "No 24h guide entries found for:"
    echo "  $NUM â€“ $NAME"
    echo
    read -rp "ENTER..." _
    return
  fi

  local pick
  pick=$(
    awk -F'\t' '{printf "ðŸ§± %s  %s\n", $3, $4}' "$GUIDE24_MAP" ; echo "â¬… Back" |
    fzf --ansi \
        --prompt="TV â–¸ Guide24 â–¸ $NUM ($(clock12)) > " \
        --header="ENTER: choose a block â€¢ ESC: back" \
        --height=100% --reverse --border
  ) || true

  [ -z "${pick:-}" ] && return
  echo "$pick" | grep -q "â¬… Back" && return

  # find block by label+title match
  local label title st en
  label=$(echo "$pick" | sed 's/^ðŸ§± *\([^ ]* [AP]Mâ€“[^ ]* [AP]M\).*/\1/' || true)
  title=$(echo "$pick" | sed 's/^ðŸ§± *[^ ]* [AP]Mâ€“[^ ]* [AP]M  //' || true)

  # locate exact
  local row
  row=$(awk -F'\t' -v t="$title" -v l="$label" '
    $3==l && $4==t {print; exit}
  ' "$GUIDE24_MAP" || true)
  [ -z "${row:-}" ] && return
  IFS=$'\t' read -r st en _lbl _title <<< "$row"

  # second screen: record options
  local action
  action=$(
    printf "%s\n" \
      "ðŸŽ¬ Record SINGLE episode (+30s auto end)" \
      "ðŸ“º Record SERIES (every matching title on this channel)" \
      "â¬… Back" |
    fzf --ansi \
        --prompt="Record â–¸ $NUM ($(clock12)) > " \
        --header="Pick one" \
        --height=40% --reverse --border
  ) || true
  [ -z "${action:-}" ] && return
  echo "$action" | grep -q "â¬… Back" && return

  case "$action" in
    *SINGLE*)
      schedule_record_block "$URL" "$NAME" "$title" "$st" "$en" "$label" 30
      read -rp "ENTER..." _
      ;;
    *SERIES*)
      add_series_timer "$NUM" "$title"
      echo ">>> Tip: run Timers (scan EPG) to schedule upcoming episodes."
      read -rp "ENTER..." _
      ;;
  esac
}

#########################################
# QUICK GUIDE (CLICKABLE)
#########################################
quick_guide_clickable() {
  if [ ! -s "$GUIDE_LIST_CACHE" ]; then
    clear
    echo "Quick Guide not built yet."
    read -rp "ENTER..." _
    return
  fi
  local pick
  pick=$(
    cat "$GUIDE_LIST_CACHE" ; echo "[---] â¬… Back" |
    fzf --ansi \
        --prompt="TV â–¸ Quick Guide ($(clock12)) > " \
        --header="ENTER: play channel â€¢ Ctrl+G: 24h guide â€¢ ESC: back" \
        --bind="ctrl-g:accept" \
        --height=100% --reverse --border
  ) || true

  [ -z "${pick:-}" ] && return
  echo "$pick" | grep -q "â¬… Back" && return

  local num
  num=$(echo "$pick" | sed 's/^\[\s*\([0-9]\+\)\].*/\1/' 2>/dev/null || true)
  [ -z "${num:-}" ] && return

  # If user hit Ctrl+G, fzf still returns the picked row; treat it as "open 24h guide"
  # (works because header tells them)
  # We canâ€™t directly detect the key, so we do a small chooser:
  local mode
  mode=$(
    printf "%s\n" \
      "â–¶ Play channel now" \
      "ðŸ—“ï¸ Open 24h guide (record blocks)" \
      "â¬… Back" |
    fzf --ansi --prompt="Quick Guide â–¸ Action ($(clock12)) > " --height=40% --reverse --border
  ) || true
  [ -z "${mode:-}" ] && return
  echo "$mode" | grep -q "â¬… Back" && return

  case "$mode" in
    *Play*) play_channel "$num" "$TABLE" ;;
    *24h*)  channel_guide_24h "$num" "$TABLE" ;;
  esac
}

#########################################
# IPTV-ORG GLOBAL (CLICKABLE) + 1080 HDTV
#########################################
iptv_ensure_playlist() {
  local file="$1" url="$2" label="$3"
  if [ -s "$file" ]; then return 0; fi
  echo ">>> Downloading $label..."
  curl -sS -L "$url" -o "$file"
}

iptv_build_tmp_from_playlist() {
  local src="$1" tmp="$2"
  awk -v OFS='\t' '
    BEGIN{name=""}
    /^#EXTINF/{
      name=$0
      sub(/.*,/,"",name)
      next
    }
    /^https?:\/\//{
      if (name=="") name="Unknown"
      print name,$0
      name=""
    }
  ' "$src" > "$tmp"
}

iptv_play_channel() {
  local IDX="$1" TABLE="$2"
  local LAST NAME URL
  LAST=$(awk 'END{print NR}' "$TABLE")
  while true; do
    NAME=$(awk -F'\t' -v i="$IDX" 'NR==i{print $1}' "$TABLE")
    URL=$(awk -F'\t' -v i="$IDX" 'NR==i{print $2}' "$TABLE")

    clear
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    printf "â•‘ TV â–¸ Global â–¸ Watching    %-10s â•‘\n" "$(clock12)"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo -e "\e[96mâ–¶ Global: $NAME\e[0m"
    echo
    recording_active && echo -e "   \e[91mâ— LIVE RECORDING (1/r to stop)\e[0m\n"
    echo "   Ctrl+Up/Down â†’ surf | 1/r â†’ live rec | q/Esc â†’ back"
    echo

    [ -z "${URL:-}" ] && { echo "No URL"; read -rp "ENTER..." _; break; }

    mpv --fullscreen --input-conf="$INPUT_CONF" "$URL"
    code=$?
    case "$code" in
      3) IDX=$((IDX+1)); [ "$IDX" -gt "$LAST" ] && IDX=1 ;;
      4) IDX=$((IDX-1)); [ "$IDX" -lt 1 ] && IDX="$LAST" ;;
      5) toggle_recording "$URL" "$NAME" "" ;;
      *) break ;;
    esac
  done
}

iptv_menu_clickable() {
  local TMP="$1" LABEL="$2"
  [ ! -s "$TMP" ] && { echo "No channels."; read -rp "ENTER..." _; return; }

  local choice idx
  choice=$(
    (awk -F'\t' '{printf "[%4d] ðŸŒ %s\n", NR, $1}' "$TMP"; echo "[----] â¬… Back") |
    fzf --ansi \
        --prompt="TV â–¸ Global â–¸ $LABEL ($(clock12)) > " \
        --header="ENTER: play â€¢ ESC/back: return" \
        --height=100% --reverse --border
  ) || true
  [ -z "${choice:-}" ] && return
  echo "$choice" | grep -q "â¬… Back" && return

  idx=$(echo "$choice" | sed 's/^\[\s*\([0-9]\+\)\].*/\1/' || true)
  [ -z "${idx:-}" ] && return
  iptv_play_channel "$idx" "$TMP"
}

iptv_search() {
  iptv_ensure_playlist "$GLOBAL_INDEX" "$GLOBAL_INDEX_URL" "global index"
  local TMP S_TMP
  TMP=$(mktemp)
  iptv_build_tmp_from_playlist "$GLOBAL_INDEX" "$TMP"

  clear
  echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
  printf "â•‘ ðŸ”  TV â–¸ Global â–¸ Search   %-10s â•‘\n" "$(clock12)"
  echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  read -rp "Search term: " Q
  [ -z "${Q:-}" ] && { rm -f "$TMP"; return; }

  S_TMP=$(mktemp)
  while IFS=$'\t' read -r name url; do
    if printf '%s\n' "$name" | grep -iF -- "$Q" >/dev/null 2>&1; then
      printf '%s\t%s\n' "$name" "$url" >> "$S_TMP"
    fi
  done < "$TMP"

  if [ ! -s "$S_TMP" ]; then
    echo "No matches."
    rm -f "$TMP" "$S_TMP"
    read -rp "ENTER..." _
    return
  fi

  iptv_menu_clickable "$S_TMP" "search: $Q"
  rm -f "$TMP" "$S_TMP"
}

build_1080_db() {
  iptv_ensure_playlist "$GLOBAL_INDEX" "$GLOBAL_INDEX_URL" "global index"
  : > "$HD1080_DB"
  python3 - "$GLOBAL_INDEX" "$HD1080_DB" << 'PY'
import sys, re

src, outp = sys.argv[1], sys.argv[2]

# category keywords (simple + effective; you can expand anytime)
CATS = [
  ("ðŸ“° News", ["news","cnn","bbc","bloomberg","al jazeera","cnbc","fox news","msnbc","sky news"]),
  ("ðŸˆ Sports", ["sport","espn","nba","nfl","mlb","nhl","ufc","f1","formula","bein","tnt sports"]),
  ("ðŸŽ¬ Movies", ["movie","cinema","hbo","starz","showtime","amc","tcm"]),
  ("ðŸ§’ Kids", ["kids","cartoon","nick","disney","baby","family"]),
  ("ðŸŽµ Music", ["music","mtv","hits","radio"]),
  ("ðŸ§  Docs", ["discovery","history","national geographic","nat geo","animal","science","documentary"]),
  ("ðŸ§³ Travel/Food", ["travel","food","cooking","kitchen"]),
]

def cat_for(name):
  low = name.lower()
  for cat, keys in CATS:
    for k in keys:
      if k in low:
        return cat
  return "ðŸ“º General"

name=None
rows=[]
with open(src,"r",encoding="utf-8",errors="ignore") as f:
  for line in f:
    line=line.strip()
    if line.startswith("#EXTINF"):
      name=line.split(",",1)[-1].strip()
    elif line.startswith("http"):
      if not name: 
        name="Unknown"
      # match 1080p/1080
      low=name.lower()
      if ("1080" in low) or ("1080p" in low):
        rows.append((name,line,cat_for(name)))
      name=None

# de-dupe by (name,url)
seen=set()
out=[]
for n,u,c in rows:
  key=(n,u)
  if key in seen: 
    continue
  seen.add(key)
  out.append((c,n,u))

out.sort(key=lambda t:(t[0], t[1].lower()))
with open(outp,"w",encoding="utf-8") as o:
  for c,n,u in out:
    o.write(f"{n}\t{u}\t{c}\n")
PY
}

hd1080_menu() {
  build_1080_db
  if [ ! -s "$HD1080_DB" ]; then
    echo "No 1080p channels found."
    read -rp "ENTER..." _
    return
  fi

  local cat
  cat=$(
    (cut -f3 "$HD1080_DB" | sort -u; echo "â¬… Back") |
    fzf --ansi --prompt="TV â–¸ 1080p HDTV â–¸ Category ($(clock12)) > " --height=60% --reverse --border
  ) || true
  [ -z "${cat:-}" ] && return
  echo "$cat" | grep -q "â¬… Back" && return

  local TMP pick idx
  TMP=$(mktemp)
  awk -F'\t' -v c="$cat" '$3==c{print $1 "\t" $2}' "$HD1080_DB" > "$TMP"

  pick=$(
    (awk -F'\t' '{printf "[%4d] ðŸ“º %s\n", NR, $1}' "$TMP"; echo "[----] â¬… Back") |
    fzf --ansi --prompt="1080p HDTV â–¸ $cat ($(clock12)) > " --height=100% --reverse --border
  ) || true
  [ -z "${pick:-}" ] && { rm -f "$TMP"; return; }
  echo "$pick" | grep -q "â¬… Back" && { rm -f "$TMP"; return; }
  idx=$(echo "$pick" | sed 's/^\[\s*\([0-9]\+\)\].*/\1/' || true)
  [ -z "${idx:-}" ] && { rm -f "$TMP"; return; }

  # Play via a 2-col temp as iptv_play_channel expects: name \t url
  local PLAYTMP
  PLAYTMP=$(mktemp)
  awk -F'\t' -v i="$idx" 'NR==i{print $1 "\t" $2}' "$TMP" > "$PLAYTMP"
  # hack: reuse iptv_play_channel by expanding single-row list into a table
  # easiest: just play directly
  local NAME URL
  NAME=$(awk -F'\t' -v i="$idx" 'NR==i{print $1}' "$TMP")
  URL=$(awk -F'\t' -v i="$idx" 'NR==i{print $2}' "$TMP")
  rm -f "$PLAYTMP" "$TMP"
  [ -z "${URL:-}" ] && return
  mpv --fullscreen --input-conf="$INPUT_CONF" "$URL"
}

#########################################
# RECORDINGS FOLDER
#########################################
open_recordings() {
  echo ">>> Opening $RECDIR"
  if command -v thunar >/dev/null 2>&1; then
    thunar "$RECDIR" >/dev/null 2>&1 &
  elif command -v xdg-open >/dev/null 2>&1; then
    xdg-open "$RECDIR" >/dev/null 2>&1 &
  else
    echo "Open manually: $RECDIR"
  fi
  read -rp "ENTER..." _
}

#########################################
# MAIN MENU (CLICKABLE + BACK SAFE)
#########################################
main_menu_clickable() {
  while true; do
    local choice
    choice=$(
      printf '%s\n' \
        "[1] ðŸ“º  TVpass Channels" \
        "[2] ðŸ—“ï¸  Quick Guide (click to play)" \
        "[3] ðŸ“†  Channel Guide (24h + record)" \
        "[4] ðŸŒ  Global Channels" \
        "[5] ðŸ›°ï¸  1080p HDTV (auto-categorized)" \
        "[6] ðŸ“‚  Recordings" \
        "[7] â±ï¸  Timers (list)" \
        "[8] ðŸ”  Timers (scan EPG)" \
        "[9] âŒ  Quit" |
      fzf --ansi \
          --prompt="TV â–¸ Main ($(clock12)) > " \
          --header="Mouse/arrows: move â€¢ ENTER: select â€¢ ESC: quit" \
          --height=100% --reverse --border
    ) || true
    [ -z "${choice:-}" ] && break

    case "$choice" in
      *"[1]"*)
        SEL=$(choose_tvpass_channel "$TABLE") || true
        [ -n "${SEL:-}" ] && play_channel "$SEL" "$TABLE"
        ;;
      *"[2]"*)
        quick_guide_clickable
        ;;
      *"[3]"*)
        # pick channel first, then show 24h guide
        SEL=$(choose_tvpass_channel "$TABLE") || true
        [ -n "${SEL:-}" ] && channel_guide_24h "$SEL" "$TABLE"
        ;;
      *"[4]"*)
        # global: by language OR search
        local g
        g=$(
          printf "%s\n" \
            "ðŸŒ Global by language" \
            "ðŸ” Global search" \
            "â¬… Back" |
          fzf --ansi --prompt="TV â–¸ Global ($(clock12)) > " --height=60% --reverse --border
        ) || true
        [ -z "${g:-}" ] && continue
        echo "$g" | grep -q "â¬… Back" && continue

        case "$g" in
          *language*)
            # minimal language menu (keep your old behavior; add back row)
            local choice2 SRC_URL SRC_FILE LABEL TMP
            choice2=$(
              printf '%s\n' \
                "ðŸŒ All languages" \
                "ðŸ‡ºðŸ‡¸ English" \
                "ðŸ‡ªðŸ‡¸ Spanish" \
                "ðŸ‡«ðŸ‡· French" \
                "ðŸ‡©ðŸ‡ª German" \
                "â¬… Back" |
              fzf --ansi --prompt="Global â–¸ Language ($(clock12)) > " --height=60% --reverse --border
            ) || true
            [ -z "${choice2:-}" ] && continue
            echo "$choice2" | grep -q "â¬… Back" && continue

            case "$choice2" in
              *All*) SRC_URL="$GLOBAL_INDEX_URL"; SRC_FILE="$GLOBAL_INDEX"; LABEL="All" ;;
              *English*) SRC_URL="https://iptv-org.github.io/iptv/languages/eng.m3u"; SRC_FILE="$TV_DIR/global-eng.m3u"; LABEL="English" ;;
              *Spanish*) SRC_URL="https://iptv-org.github.io/iptv/languages/spa.m3u"; SRC_FILE="$TV_DIR/global-spa.m3u"; LABEL="Spanish" ;;
              *French*) SRC_URL="https://iptv-org.github.io/iptv/languages/fra.m3u"; SRC_FILE="$TV_DIR/global-fra.m3u"; LABEL="French" ;;
              *German*) SRC_URL="https://iptv-org.github.io/iptv/languages/deu.m3u"; SRC_FILE="$TV_DIR/global-deu.m3u"; LABEL="German" ;;
            esac

            curl -sS -L "$SRC_URL" -o "$SRC_FILE" || { echo "Failed."; read -rp "ENTER..." _; continue; }
            TMP=$(mktemp)
            iptv_build_tmp_from_playlist "$SRC_FILE" "$TMP"
            iptv_menu_clickable "$TMP" "$LABEL"
            rm -f "$TMP"
            ;;
          *search*)
            iptv_search
            ;;
        esac
        ;;
      *"[5]"*)
        hd1080_menu
        ;;
      *"[6]"*)
        open_recordings
        ;;
      *"[7]"*)
        timers_list
        ;;
      *"[8]"*)
        timers_scan
        ;;
      *"[9]"*)
        break
        ;;
    esac
  done
}

#########################################
# ENTRY
#########################################
prevent_sleep
ensure_deps
ensure_input_conf
tvpass_ensure_playlist
tvpass_ensure_guide
detect_storage_tier

case "${1:-}" in
  update) tvpass_update_all ;;
esac

# Build TVpass table + caches
TABLE=$(build_table)
build_epg_caches_and_quickguide "$TABLE"

# Prime global caches (best-effort; don't fail if offline)
iptv_ensure_playlist "$MAIN_PLAYLIST" "$MAIN_URL" "US main" >/dev/null 2>&1 || true
iptv_ensure_playlist "$GLOBAL_INDEX" "$GLOBAL_INDEX_URL" "global index" >/dev/null 2>&1 || true

main_menu_clickable

rm -f "$TABLE"
TVEOF

chmod +x "$HOME/.local/bin/tv"

# ----------------------------
# 6) Restore recordings from backup into the new ~/TV (optional but helpful)
# ----------------------------
mkdir -p "$HOME/TV/recordings"
if [ -d "$BACKUP_DIR/recordings" ]; then
  echo ">>> Restoring recordings from backup into new install..."
  cp -a "$BACKUP_DIR/recordings/." "$HOME/TV/recordings/" 2>/dev/null || true
fi

echo "============================================"
echo " DONE."
echo " Backup saved at: $BACKUP_DIR"
echo " Run TV with: tv"
echo "============================================"
EOF
